{% extends "layout.html" %}
{% block title %} OmniRAG Chat {% endblock %}

{% block content %}
<div class="container">
  <h5>OmniRAG Chat</h5>
</div>

<form method="post" id="form" name="form" action="/conv_ai_console">
  <input type="hidden" id="conversation_id" name="conversation_id" value="{{ conversation_id }}">
  <input type="hidden" id="custom_rules" name="custom_rules" value="">

  <div class="container">
    <div class="card caig-card" style="width: 100%;">
      <div class="card-body bg-dark text-light">
        <p class="card-title text-end fw-light fs-6">Conversation ID: {{ conversation_id }}</p>
        <p></p>

        {# Sort primarily by index, with created_at as stable secondary sort #}
        {% set sorted_completions = conv["completions"]|sort(attribute='created_at')|sort(attribute='index') %}
        {% for comp in sorted_completions %}
        {% set content_lines = comp["content"].split("\n") %}
        <div style="background-color: #083a5b; padding: 16px; margin: 0 -1.25rem;">
          <p class="text-start fw-bold fs-6 mb-0" style="color: #79c2ff; margin: 0;">
            {{ comp["user_text"] }}
          </p>
        </div>
        <div style="background-color: #2f3336; padding: 20px; margin: 0 -1.25rem;">
          <div class="text-start fs-6" style="margin: 0;">
            {{ comp["content"] | markdown | safe }}
          </div>
        </div>
        <p class="text-start fw-light fs-6 text-muted mt-2 mb-4">
          Prompt tokens: {{ comp["usage"]["prompt_tokens"] }},
          Completion tokens: {{ comp["usage"]["completion_tokens"] }},
          Total tokens: {{ comp["usage"]["total_tokens"] }},
          RAG strategy: {{ comp["rag_strategy"] }}
        </p>
        
        {# Toggle buttons for this specific completion #}
        <div class="row mb-3">
          <div class="col-auto text-end ms-auto">
            <div class="btn-group btn-group-sm" role="group" aria-label="Completion actions">
              <button type="button" class="btn btn-outline-secondary comp-feedback-button" 
                data-comp-id="{{ comp['completion_id'] }}" data-comp-index="{{ loop.index0 }}">Feedback</button>
              <button type="button" class="btn btn-outline-secondary comp-prompts-button" 
                data-comp-id="{{ comp['completion_id'] }}" data-comp-index="{{ loop.index0 }}">Prompts</button>
              <button type="button" class="btn btn-outline-secondary comp-json-button" 
                data-comp-id="{{ comp['completion_id'] }}" data-comp-index="{{ loop.index0 }}">Session Log</button>
            </div>
          </div>
        </div>

        {# Feedback section for this completion #}
        <div class="container comp-feedback-div" id="feedback_div_{{ loop.index0 }}" style="display: none;" data-comp-index="{{ loop.index0 }}">
          <div style="background-color: #2f3336; padding: 20px; margin: 0 -1.25rem;">
            <h6 class="text-light">Feedback for this response</h6>
            <form method="post" class="comp-feedback-form" action="/conv_ai_feedback">
              <input type="hidden" name="conversation_id" value="{{ conversation_id }}">
              <input type="hidden" name="completion_id" value="{{ comp['completion_id'] }}">
              <div>
                <label class="form-label fs-6 text-light">Question: {{ comp["user_text"] }}</label><br />
                <input class="form-control bg-dark text-light border-secondary" type="text" name="feedback_user_feedback"
                  placeholder="Enter your feedback for this response:"><br />
                <div>
                  <button type="submit" class="btn btn-outline-primary comp-feedback-submit-button">Submit Feedback</button>
                </div>
              </div>
            </form>
          </div>
        </div>

        {# Prompts section for this completion #}
        <div class="container comp-prompts-div" id="prompts_div_{{ loop.index0 }}" style="display: none;" data-comp-index="{{ loop.index0 }}">
          <div style="background-color: #2f3336; padding: 20px; margin: 0 -1.25rem;">
            <h6 class="text-light">Prompts for this response:</h6>
            <pre style="background-color: #2f3336; color: #ffffff; border: none; padding: 0; margin: 0;"><code>{% if conv.prompts and conv.prompts|length > loop.index0 %}{{ conv.prompts[loop.index0] }}{% else %}No prompt available for this completion{% endif %}</code></pre>
          </div>
        </div>

        {# Session log section for this completion #}
        <div class="container comp-json-div" id="json_div_{{ loop.index0 }}" style="display: none;" data-comp-index="{{ loop.index0 }}">
          <div style="background-color: #2f3336; padding: 20px; margin: 0 -1.25rem;">
            <h6 class="text-light">Session log for this response:</h6>
            <pre style="background-color: #2f3336; color: #ffffff; border: none; padding: 0; margin: 0;"><code class="language-json" id="json-code-{{ loop.index0 }}">{{ comp | tojson }}</code></pre>
          </div>
        </div>

        {% if not loop.last %}<hr>{% endif %}
        {% endfor %}
        <hr>
        <div class="row align-items-end mb-3">
          <div class="col-auto">
            <label class="form-label fs-6 d-block">RAG data source:</label>
            <div class="btn-group" role="group" aria-label="RAG strategy">
              <input type="radio" class="btn-check" name="rag_strategy" id="rag_auto" autocomplete="off" value="auto" {%
                if rag_strategy=='auto' or not rag_strategy %}checked{% endif %}>
              <label class="btn btn-sm btn-outline-secondary" for="rag_auto">Auto</label>

              <input type="radio" class="btn-check" name="rag_strategy" id="rag_db" autocomplete="off" value="db" {% if
                rag_strategy=='db' %}checked{% endif %}>
              <label class="btn btn-sm btn-outline-secondary" for="rag_db">DB</label>

              <input type="radio" class="btn-check" name="rag_strategy" id="rag_vector" autocomplete="off"
                value="vector" {% if rag_strategy=='vector' %}checked{% endif %}>
              <label class="btn btn-sm btn-outline-secondary" for="rag_vector">Vector</label>

              <input type="radio" class="btn-check" name="rag_strategy" id="rag_graph" autocomplete="off" value="graph"
                {% if rag_strategy=='graph' %}checked{% endif %}>
              <label class="btn btn-sm btn-outline-secondary" for="rag_graph">Graph</label>
            </div>
          </div>
          <div class="col">
            <label class="form-label fs-6" for="user_text">Enter your request:</label>
            <input class="form-control" type="text" id="user_text" name="user_text"
              placeholder="Enter your request here. Triple-click for suggestions.">
          </div>
          <div class="col-auto">
            <label class="form-label fs-6 d-block">&nbsp;</label>
            <button type="button" class="btn btn-outline-primary" id="continue_button"
              name="continue_button">Submit</button>
          </div>
        </div>
        <div class="row">
          <div class="col">
            <p class="text-danger fw-bold" id="error_message" name="error_message" style="display: none;"></p>
          </div>
        </div>
      </div>
    </div>
  </div>
</form>

<!-- Prism.js for JSON syntax highlighting - loaded conditionally -->
<div id="prism-resources" style="display: none;">
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
</div>

{% endblock %}

{% block js %}
<style>
  /* full-bleed helpers: let background blocks reach the card-body edges while keeping inner content padded */
  .full-bleed {
    width: calc(100% + 2.5rem); /* compensate for .card-body default horizontal padding (1.25rem each side) */
    margin-left: -1.25rem;
    margin-right: -1.25rem;
    box-sizing: border-box;
  }
  .full-bleed .full-bleed-inner {
    padding-left: 1.25rem;
    padding-right: 1.25rem;
  }
</style>
<script>
  const form = document.getElementById("form");
  var user_text = document.getElementById("user_text");
  const continue_button = document.getElementById("continue_button");
  const error_message = document.getElementById("error_message");

  // Session state keys for toggle persistence (per completion)
  const CONVERSATION_ID = document.getElementById('conversation_id').value;

  function scrollToBottom() {
    try {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    } catch (e) {
      // no-op
    }
  }

  // Lazy load Prism.js for JSON syntax highlighting
  function loadPrismResources() {
    return new Promise((resolve) => {
      // Check if Prism is already loaded
      if (window.Prism) {
        resolve();
        return;
      }
      
      const prismContainer = document.getElementById('prism-resources');
      if (prismContainer) {
        // Make Prism resources visible to load them
        prismContainer.style.display = 'block';
        
        // Wait for scripts to load
        const checkPrism = () => {
          if (window.Prism) {
            resolve();
          } else {
            setTimeout(checkPrism, 100);
          }
        };
        checkPrism();
      } else {
        resolve();
      }
    });
  }

  // Apply JSON syntax highlighting to all visible code blocks
  async function highlightJsonCode() {
    // Load Prism for syntax highlighting
    await loadPrismResources();
    
    // Apply syntax highlighting if Prism is available
    if (window.Prism) {
      const codeElements = document.querySelectorAll('code.language-json');
      codeElements.forEach(codeElement => {
        Prism.highlightElement(codeElement);
      });
    }
  }

  // Restore toggle states for all completions
  function restoreToggleStates() {
    try {
      // Get all completion sections
      const feedbackDivs = document.querySelectorAll('.comp-feedback-div');
      const promptsDivs = document.querySelectorAll('.comp-prompts-div');
      const jsonDivs = document.querySelectorAll('.comp-json-div');
      
      // Restore feedback states
      feedbackDivs.forEach(div => {
        const compIndex = div.dataset.compIndex;
        const key = `conv_feedback_toggle_${CONVERSATION_ID}_${compIndex}`;
        const state = sessionStorage.getItem(key);
        const button = document.querySelector(`[data-comp-index="${compIndex}"].comp-feedback-button`);
        
        if (state === 'visible') {
          div.style.display = "block";
          if (button) button.classList.add('btn-toggle-active');
        } else {
          div.style.display = "none";
          if (button) button.classList.remove('btn-toggle-active');
        }
      });

      // Restore prompts states
      promptsDivs.forEach(div => {
        const compIndex = div.dataset.compIndex;
        const key = `conv_prompts_toggle_${CONVERSATION_ID}_${compIndex}`;
        const state = sessionStorage.getItem(key);
        const button = document.querySelector(`[data-comp-index="${compIndex}"].comp-prompts-button`);
        
        if (state === 'visible') {
          div.style.display = "block";
          if (button) button.classList.add('btn-toggle-active');
        } else {
          div.style.display = "none";
          if (button) button.classList.remove('btn-toggle-active');
        }
      });

      // Restore JSON states
      jsonDivs.forEach(div => {
        const compIndex = div.dataset.compIndex;
        const key = `conv_json_toggle_${CONVERSATION_ID}_${compIndex}`;
        const state = sessionStorage.getItem(key);
        const button = document.querySelector(`[data-comp-index="${compIndex}"].comp-json-button`);
        
        if (state === 'visible') {
          div.style.display = "block";
          if (button) button.classList.add('btn-toggle-active');
        } else {
          div.style.display = "none";
          if (button) button.classList.remove('btn-toggle-active');
        }
      });
      
      // Apply JSON syntax highlighting to any visible JSON sections
      highlightJsonCode();
    } catch (e) {
      console.warn('Error restoring toggle states:', e);
    }
  }

  user_text.focus();
  continue_button.disabled = true;
  error_message.style.display = "none";
  
  // Restore previous toggle states
  restoreToggleStates();
  // ensure latest completion is visible on render
  document.addEventListener('DOMContentLoaded', scrollToBottom);

  var suggestions_index = -1;
  var suggestions = [
    "what are the dependencies of the python library called flask?",
    "Look up record flask",
    "What are the possible alternatives to it?",
    "Is there an asynchronous version of flask?"
  ];

  let clickCount = 0;
  let clickTimer = null;

  user_text.addEventListener('click', function (event) {
    clickCount++;
    if (clickCount === 1) {
      clickTimer = setTimeout(function () {
        clickCount = 0;
      }, 400);
    } else if (clickCount === 3) {
      clearTimeout(clickTimer);
      clickCount = 0;
      suggestions_index++;
      if (suggestions_index >= suggestions.length) {
        suggestions_index = 0;
      }
      user_text.value = suggestions[suggestions_index];
      continue_button.disabled = false;
    }
  });

  // remove duplicate submit bindings and guard against double submit
  let isSubmitting = false;
  function triggerSubmit() {
    user_text = document.getElementById("user_text");
    if (isSubmitting) {
      return;
    }
    if (user_text && user_text.value.trim().length > 0) {
      isSubmitting = true;
      continue_button.disabled = true;
      continue_button.classList.add('processing');
      continue_button.textContent = "Processing...";
      error_message.style.display = "none"; // Hide any previous errors
      
      // Store the submission time to detect if the page takes too long
      sessionStorage.setItem('conv_ai_form_submit_time', Date.now().toString());
      
      form.submit();
    }
  }

  continue_button.addEventListener('click', function (event) {
    console.log("continue_button click");
    event.preventDefault();
    triggerSubmit();
  });

  // Submit on Enter key in the text box
  user_text.addEventListener('keydown', function (event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      triggerSubmit();
    }
  });

  // Event delegation for completion-specific toggle buttons
  document.addEventListener('click', function(event) {
    const target = event.target;
    
    // Handle feedback button clicks
    if (target.classList.contains('comp-feedback-button')) {
      event.preventDefault();
      const compIndex = target.dataset.compIndex;
      const feedbackDiv = document.getElementById(`feedback_div_${compIndex}`);
      const key = `conv_feedback_toggle_${CONVERSATION_ID}_${compIndex}`;
      
      if (feedbackDiv.style.display === "none" || feedbackDiv.style.display === "") {
        feedbackDiv.style.display = "block";
        target.classList.add('btn-toggle-active');
        sessionStorage.setItem(key, 'visible');
      } else {
        feedbackDiv.style.display = "none";
        target.classList.remove('btn-toggle-active');
        sessionStorage.setItem(key, 'hidden');
      }
    }
    
    // Handle prompts button clicks
    if (target.classList.contains('comp-prompts-button')) {
      event.preventDefault();
      const compIndex = target.dataset.compIndex;
      const promptsDiv = document.getElementById(`prompts_div_${compIndex}`);
      const key = `conv_prompts_toggle_${CONVERSATION_ID}_${compIndex}`;
      
      if (promptsDiv.style.display === "none" || promptsDiv.style.display === "") {
        promptsDiv.style.display = "block";
        target.classList.add('btn-toggle-active');
        sessionStorage.setItem(key, 'visible');
      } else {
        promptsDiv.style.display = "none";
        target.classList.remove('btn-toggle-active');
        sessionStorage.setItem(key, 'hidden');
      }
    }
    
    // Handle JSON button clicks
    if (target.classList.contains('comp-json-button')) {
      event.preventDefault();
      const compIndex = target.dataset.compIndex;
      const jsonDiv = document.getElementById(`json_div_${compIndex}`);
      const key = `conv_json_toggle_${CONVERSATION_ID}_${compIndex}`;
      
      if (jsonDiv.style.display === "none" || jsonDiv.style.display === "") {
        jsonDiv.style.display = "block";
        target.classList.add('btn-toggle-active');
        sessionStorage.setItem(key, 'visible');
        // Apply JSON syntax highlighting when section becomes visible
        highlightJsonCode();
      } else {
        jsonDiv.style.display = "none";
        target.classList.remove('btn-toggle-active');
        sessionStorage.setItem(key, 'hidden');
      }
    }
    
    // Handle feedback form submission
    if (target.classList.contains('comp-feedback-submit-button')) {
      event.preventDefault();
      const form = target.closest('.comp-feedback-form');
      const formData = new FormData(form);
      const postObj = {
        conversation_id: formData.get('conversation_id'),
        completion_id: formData.get('completion_id'),
        feedback_user_feedback: formData.get('feedback_user_feedback')
      };
      
      fetch('/conv_ai_feedback', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(postObj)
      })
      .then(response => response.text())
      .then(data => {
        console.log('Feedback submitted:', data);
        // Clear the feedback input
        const feedbackInput = form.querySelector('input[name="feedback_user_feedback"]');
        if (feedbackInput) feedbackInput.value = "";
        // Hide the feedback div
        const compIndex = target.closest('.comp-feedback-div').dataset.compIndex;
        const feedbackDiv = document.getElementById(`feedback_div_${compIndex}`);
        const feedbackButton = document.querySelector(`[data-comp-index="${compIndex}"].comp-feedback-button`);
        feedbackDiv.style.display = "none";
        feedbackButton.classList.remove('btn-toggle-active');
        const key = `conv_feedback_toggle_${CONVERSATION_ID}_${compIndex}`;
        sessionStorage.setItem(key, 'hidden');
      })
      .catch(error => {
        console.error('Error submitting feedback:', error);
      });
    }
  });

  user_text.addEventListener("input", () => {
    console.log("user_text: " + user_text.value);
    if (user_text.value.trim().length > 0) {
      continue_button.disabled = false;
    }
    else {
      continue_button.disabled = true;
    }
  });

  // Local Storage Management for user input
  const STORAGE_KEY = 'conv_ai_console_user_text';
  const CONVERSATION_ID_KEY = 'conv_ai_console_conversation_id';

  // Store conversation ID in localStorage for session clearing
  const conversationIdInput = document.getElementById('conversation_id');
  if (conversationIdInput && conversationIdInput.value) {
    try {
      localStorage.setItem(CONVERSATION_ID_KEY, conversationIdInput.value);
    } catch (e) {
      console.warn('Error storing conversation ID:', e);
    }
  }

  // Load saved value from localStorage
  function loadFromLocalStorage() {
    try {
      const savedValue = localStorage.getItem(STORAGE_KEY);
      if (savedValue && user_text) {
        user_text.value = savedValue;
        // Enable submit button if there's saved content
        if (savedValue.trim().length > 0) {
          continue_button.disabled = false;
        }
      }
    } catch (e) {
      console.warn('Error loading from localStorage:', e);
    }
  }

  // Save value to localStorage
  function saveToLocalStorage() {
    try {
      if (user_text) {
        localStorage.setItem(STORAGE_KEY, user_text.value);
      }
    } catch (e) {
      console.warn('Error saving to localStorage:', e);
    }
  }

  // Set up event listeners for auto-saving
  function setupAutoSave() {
    if (user_text) {
      user_text.addEventListener('blur', saveToLocalStorage);
    }
  }

  // Initialize localStorage functionality
  document.addEventListener('DOMContentLoaded', function() {
    loadFromLocalStorage();
    setupAutoSave();
    
    // Check if we just submitted a form and detect if it was successful
    const submitTime = sessionStorage.getItem('conv_ai_form_submit_time');
    const completionsBefore = sessionStorage.getItem('conv_ai_completions_before_submit');
    
    if (submitTime && completionsBefore) {
      const timeDiff = Date.now() - parseInt(submitTime);
      const currentCompletions = document.querySelectorAll('[style*="background-color: #2f3336"]').length;
      const completionsBeforeCount = parseInt(completionsBefore);
      
      // If page reloaded quickly OR no new completions were added, likely an error
      if (timeDiff < 3000 || currentCompletions <= completionsBeforeCount) {
        let errorMsg = "An error occurred while processing your request.";
        if (timeDiff < 1000) {
          errorMsg += " The request failed very quickly - this may indicate a server configuration issue.";
        } else if (currentCompletions <= completionsBeforeCount) {
          errorMsg += " No response was generated - this may be due to rate limits or service errors.";
        }
        errorMsg += " Please try again in a few moments.";
        
        error_message.textContent = errorMsg;
        error_message.style.display = "block";
      }
      
      // Clear the submit tracking data
      sessionStorage.removeItem('conv_ai_form_submit_time');
      sessionStorage.removeItem('conv_ai_completions_before_submit');
    }
  });

  // Clear localStorage when form is successfully submitted
  const originalTriggerSubmit = triggerSubmit;
  triggerSubmit = function() {
    if (user_text && user_text.value.trim().length > 0) {
      // Load custom rules from sessionStorage and inject into form
      const customRules = sessionStorage.getItem('sparql_custom_rules') || '';
      const customRulesInput = document.getElementById('custom_rules');
      if (customRulesInput) {
        customRulesInput.value = customRules;
      }
      
      // Store conversation state before submission to detect changes
      const completionsCount = document.querySelectorAll('[style*="background-color: #2f3336"]').length;
      sessionStorage.setItem('conv_ai_completions_before_submit', completionsCount.toString());
      
      // Clear the saved text before submitting since we're about to process it
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (e) {
        console.warn('Error clearing localStorage on submit:', e);
      }
    }
    originalTriggerSubmit();
  };

</script>
{% endblock %}