{% extends "layout.html" %}
{% block title %} SPARQL Console {% endblock %}

{% block content %}
<style>
  /* Style for edge labels - D3.js specific */
  .link-label {
    font-family: Arial, sans-serif;
    text-shadow: none !important;
  }

  /* Style for node labels - D3.js specific */
  .node text {
    text-shadow: none !important;
    font-family: Arial, sans-serif;
  }

  /* Remove all padding from caig-inner-body - page specific */
  .caig-inner-body {
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<div class="container">
  <h5>SPARQL Console</h5>
  <p></p>
  <div class="card caig-card" style="width: 100%;">
    <div class="card-body bg-dark text-light caig-inner-body">
      <form method="post" id="form" name="form">
        <div class="mb-3">
          <label for="sparql" class="form-label">SPARQL query:</label>
          <textarea rows='8' class="form-control" id="sparql" name="sparql" value="{{ sparql }}">{{ sparql }}</textarea>
          <script>
            var editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
              mode: "sparql",
              lineNumbers: true,
              theme: "default"
            });
            function resizeCodeMirrorToContent(cm) {
              var doc = cm.getDoc();
              var lineCount = doc.lineCount();
              var newHeight = (lineCount + 1) * 24; // 24px is the default line height
              cm.setSize(null, newHeight + "px");
            }
            resizeCodeMirrorToContent(editor);
            editor.on("change", function (cm) {
              resizeCodeMirrorToContent(cm);
            });
          </script>
        </div>
        <div class="mb-3">
          <label for="bom_query" class="form-label">Entity name, space and dependency depth:</label>
          <input type="text" class="form-control" id="bom_query" name="bom_query" value="{{ bom_query }}"
            placeholder="<Entity ID/name> <Depth>"></input>
        </div>
        <div class="mb-6">
          <button type="submit" id="submit_button" name="submit_button"
            class="btn btn-outline-primary mb-3">Submit</button>
        </div>
        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
    </div>
    <div id="viz_wrapper" class="container-fluid p-0" style="display:none;">
      <h5 style="padding-left: 12px;">{{ visualization_message }}</h5>
      <div class="bg-dark" id="d3viz" name="d3viz" style="width:100%; height:800px; overflow:auto;">
        <svg id="graph-svg" style="width:100%; height:100%; display:block;" preserveAspectRatio="xMidYMid meet">
          <g id="graph-container"></g>
        </svg>
      </div>
      <div style="display: none;" id="inline_bom_json" name="inline_bom_json">
        {{ inline_bom_json }}
      </div>
    </div>   
    <div class="container" id="results_div" name="results_div">
      {% set computed_count = count if count else 0 %}
      {% if (not computed_count) and results %}
      {# SPARQL (Apache Jena) JSON shape: results -> { head, results: { bindings: [...] } } #}
      {% if results.results is defined and results.results.results is defined and results.results.results.bindings is
      defined %}
      {% set computed_count = results.results.results.bindings | length %}
      {% elif results.results is defined and results.results.bindings is defined %}
      {% set computed_count = results.results.bindings | length %}
      {% elif results.nodes is defined %}
      {% set computed_count = results.nodes | length %}
      {% elif results.libs is defined %}
      {% set computed_count = results.libs | length %}
      {% endif %}
      {% endif %}

      <div class="d-flex justify-content-between align-items-center">
        <h5>{{ results_message}}</h5>
        {% if computed_count and computed_count > 0 %}
        <h6 class="text-muted mb-0">Total Results: {{ computed_count }}</h6>
        {% elif results %}
        <h6 class="text-muted mb-0">Results returned (count not provided)</h6>
        {% endif %}
      </div>
      {% if results %}
      <pre><code class="language-json">{{ results | tojson | safe }}</code></pre> {% endif %}
      <!-- Prism.js for JSON syntax highlighting -->
      <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-sparql.min.js"></script>
    </div>


  </div>
</div>

{% endblock %}

{% block js %}
<script>
  console.log('Script block started');
  console.log('D3 available:', typeof d3 !== 'undefined');
  console.log('jQuery available:', typeof $ !== 'undefined');

  const form = document.getElementById("form");
  const submit_button = document.getElementById("submit_button");

  submit_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      submit_button.disabled = true;
      submit_button.textContent = "Processing...";
      form.submit();
    }
  );

  // Use regular DOM ready instead of jQuery if it's not available
  function domReady(fn) {
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(fn, 1);
    } else {
      document.addEventListener("DOMContentLoaded", fn);
    }
  }

  domReady(function () {
    console.log('DOM ready, starting processing');

    var method = "{{ method }}";
    var libtype = "{{ libtype }}";
    var libtype_prefix_idx = libtype.length + 1;

    // Helper function to generate consistent colors for nodes
    function getNodeColor(nodeName, depth) {
      // Create a simple hash function for consistent colors
      let hash = 0;
      for (let i = 0; i < nodeName.length; i++) {
        const char = nodeName.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }

      // Generate a color based on the hash
      const hue = Math.abs(hash) % 360;

      // Calculate lightness based on depth - 0 is brightest, higher depth is dimmer
      // Start at 70% lightness for depth 0, decrease by 10% per depth level, minimum 20%
      const lightness = Math.max(20, 70 - (depth * 10));

      return `hsl(${hue}, 70%, ${lightness}%)`;
    }

    // Test basic D3 functionality
    console.log('Testing D3.js...');
    try {
      d3.select("#graph-svg")
        .append("circle")
        .attr("cx", 50)
        .attr("cy", 50)
        .attr("r", 10)
        .style("fill", "green");
      console.log('D3 test circle added successfully');
    } catch (e) {
      console.error('D3 test failed:', e);
    }

    // Get the Bill-of-Materials (BOM) data that is embedded in the page.
    var bomElement = document.getElementById("inline_bom_json");
    console.log('BOM element found:', !!bomElement);

    if (!bomElement) {
      console.error('inline_bom_json element not found');
      // Keep visualization hidden when there is nothing to render
      const wrapper = document.getElementById('viz_wrapper');
      if (wrapper) wrapper.style.display = 'none';
      return;
    }

    var bom_json = bomElement.innerHTML.trim();
    console.log('Raw BOM JSON length:', bom_json.length);
    console.log('Raw BOM JSON first 300 chars:', bom_json.substring(0, 300));

    // Show the raw content in the SVG for debugging
    // Do not show any preview text when hidden
    d3.select("#graph-svg").selectAll("*").remove();

    if (bom_json && bom_json.trim() !== '') {
      // Clean up the JSON string - fix Python-style booleans, None values, and quotes
      bom_json = bom_json.trim()
        .replaceAll("'", "\"")
        .replaceAll(": False", ": false")
        .replaceAll(": True", ": true")
        .replaceAll(":False", ":false")
        .replaceAll(":True", ":true")
        .replaceAll(": None", ": null")
        .replaceAll(":None", ":null");

      console.log('Cleaned JSON first 500 chars:', bom_json.substring(0, 500));

      try {
        var bom_obj = JSON.parse(bom_json);
        console.log('BOM data parsed successfully');
        console.log('BOM object keys:', Object.keys(bom_obj));

        // Clear any debug info; we'll render only if nodes exist
        d3.select("#graph-svg").selectAll("*").remove();

        // Transform the BOM data into a structure that is usable by D3.js to render the graph.
        var nodes = Array();
        var edges = Array();
        var nodes_set = new Set();

        // Handle the new JSON structure with 'nodes' property
        if (bom_obj.hasOwnProperty('nodes')) {
          console.log('Found nodes property with', Object.keys(bom_obj.nodes).length, 'entries');
          var bom_nodes = bom_obj['nodes'];
          var node_keys = Object.keys(bom_nodes);

          for (let i = 0; i < node_keys.length; i++) {
            var node_key = node_keys[i];
            var node_data = bom_nodes[node_key];

            // Extract clean node name (remove URI prefix if present)
            var clean_name = node_data.name || node_key;
            if (clean_name.includes('#')) {
              clean_name = clean_name.split('#').pop();
            }

            console.log('Processing node:', clean_name, 'with dependencies:', node_data.dependencies);
            console.log('Adding to nodes_set:', clean_name);
            nodes_set.add(clean_name);

            // Process rich dependencies if available (new enhanced format)
            var richDependencies = node_data.richDependencies;
            if (Array.isArray(richDependencies) && richDependencies.length > 0) {
              console.log('Found rich dependencies:', richDependencies.length);
              
              for (let d = 0; d < richDependencies.length; d++) {
                var richDep = richDependencies[d];
                var dep_uri = richDep.uri;
                var dep_clean_name = richDep.name || dep_uri;

                // Clean up dependency name (remove URI prefix if present)
                if (typeof dep_clean_name === 'string' && dep_clean_name.includes('#')) {
                  dep_clean_name = dep_clean_name.split('#').pop();
                }

                // Create edges with rich information
                if (dep_clean_name !== clean_name &&
                  dep_clean_name.length > 0 &&
                  dep_clean_name.trim() !== '') {

                  console.log('Creating rich edge:', clean_name, '->', dep_clean_name, 'with properties:', richDep.properties);
                  nodes_set.add(dep_clean_name);

                  var edge = {};
                  edge["source"] = clean_name;
                  edge["target"] = dep_clean_name;
                  console.log('Creating edge:', clean_name, '->', dep_clean_name);
                  edge["weight"] = 1.0;
                  
                  // Use rich dependency data for meaningful edge labels
                  edge["label"] = richDep.edgeLabel || "connects";
                  edge["displayLabel"] = richDep.displayLabel || dep_clean_name;
                  edge["tooltipText"] = richDep.tooltipText || "";
                  edge["properties"] = richDep.properties || {};
                  edge["type"] = richDep.type || "connection";
                  
                  // Extract specific engineering properties for enhanced visualization
                  if (richDep.properties) {
                    edge["itemTag"] = richDep.properties.ItemTag || "";
                    edge["nominalDiameter"] = richDep.properties.NominalDiameter || "";
                    edge["flowDir"] = richDep.properties.FlowDir || "";
                    edge["drawingNumber"] = richDep.properties.DrawingNumber || "";
                  }
                  
                  edges.push(edge);
                }
              }
            }
            // Fallback to legacy dependencies if no rich dependencies available
            else {
              var dependencies = node_data.dependencies;
              if (Array.isArray(dependencies)) {
                console.log('Using legacy dependencies format');
                
                for (let d = 0; d < dependencies.length; d++) {
                  var dep_uri = dependencies[d];
                  var dep_clean_name = dep_uri;

                  // Clean up dependency name (remove URI prefix if present)
                  if (typeof dep_uri === 'string' && dep_uri.includes('#')) {
                    dep_clean_name = dep_uri.split('#').pop();
                  }

                  // Create edges for all meaningful dependencies
                  // Only skip exact self-references and empty strings
                  if (dep_clean_name !== clean_name &&
                    dep_clean_name.length > 0 &&
                    dep_clean_name.trim() !== '') {

                    console.log('Creating legacy edge:', clean_name, '->', dep_clean_name);
                    nodes_set.add(dep_clean_name);

                    var edge = {};
                    edge["source"] = clean_name;
                    edge["target"] = dep_clean_name;
                    edge["weight"] = 1.0;
                    edge["label"] = "depends on";
                    edges.push(edge);
                  }
                }
              }
            }
          }
        }
        // Fallback: Handle legacy 'libs' structure for backwards compatibility
        else if (bom_obj.hasOwnProperty('libs')) {
          console.log('Found libs property - using legacy format');
          var bom_libs = bom_obj['libs'];
          var lib_keys = Object.keys(bom_libs);

          for (let i = 0; i < lib_keys.length; i++) {
            var lib_key = lib_keys[i];
            var lib_key_tokens = lib_key.split("#");
            var lib_key_no_prefix = lib_key_tokens[1] || lib_key;
            nodes_set.add(lib_key_no_prefix);

            var dep_libs = bom_libs[lib_key]["dependencies"];
            if (Array.isArray(dep_libs)) {
              for (let d = 0; d < dep_libs.length; d++) {
                var dep_lib_uri = dep_libs[d];
                var dep_lib_uri_tokens = dep_lib_uri.split("#");
                var dep_lib_no_prefix = dep_lib_uri_tokens[1] || dep_lib_uri;
                nodes_set.add(dep_lib_no_prefix);

                var edge = {};
                edge["source"] = lib_key_no_prefix;
                edge["target"] = dep_lib_no_prefix;
                edge["weight"] = 1.0;
                edge["label"] = "depends on";
                edges.push(edge);
              }
            }
          }
        } else {
          console.log('No recognized data structure found. Available keys:', Object.keys(bom_obj));
        }

        // Function to fetch node properties using SPARQL
        async function fetchNodeProperties(nodeId) {
          try {
            console.log(`Fetching properties for node: ${nodeId}`);
            
            // Create SPARQL query to get node properties
            const sparqlQuery = `
              PREFIX owl: <http://www.w3.org/2002/07/owl#>
              PREFIX schema: <http://schema.org/ontology#>
              SELECT ?property ?value WHERE {
                <http://schema.org/ontology#${nodeId}> ?property ?value .
                FILTER(?property != <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>)
              }
            `;
            
            console.log('SPARQL query for node properties:', sparqlQuery);
            
            // Post SPARQL query to the backend
            const response = await fetch('/sparql_console', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body: new URLSearchParams({
                'sparql': sparqlQuery,
                'bom_query': ''
              })
            });
            
            if (!response.ok) {
              console.error('Failed to fetch node properties:', response.status);
              return {};
            }
            
            const responseText = await response.text();
            console.log('Raw SPARQL response for node properties:', responseText.substring(0, 500));
            
            // Parse the response to extract properties
            // This is a simplified parser - in production you'd want more robust parsing
            const properties = {};
            
            try {
              // Try to extract JSON from the response
              const jsonMatch = responseText.match(/"results":\s*{[^}]*"bindings":\s*\[([^\]]*)\]/);
              if (jsonMatch) {
                const bindingsText = jsonMatch[1];
                console.log('Bindings text:', bindingsText);
                
                // Parse individual bindings
                const bindingMatches = bindingsText.match(/{[^}]*}/g);
                if (bindingMatches) {
                  bindingMatches.forEach(binding => {
                    const propMatch = binding.match(/"property":\s*{\s*"value":\s*"([^"]*)".*?"value":\s*{\s*"value":\s*"([^"]*)"/);
                    if (propMatch) {
                      const propUri = propMatch[1];
                      const propValue = propMatch[2];
                      
                      // Extract property name from URI
                      let propName = propUri;
                      if (propUri.includes('#')) {
                        propName = propUri.split('#').pop();
                      }
                      
                      properties[propName] = propValue;
                      console.log(`Extracted property: ${propName} = ${propValue}`);
                    }
                  });
                }
              }
            } catch (parseError) {
              console.error('Error parsing SPARQL response:', parseError);
            }
            
            console.log('Final extracted properties for', nodeId, ':', properties);
            return properties;
            
          } catch (error) {
            console.error('Error fetching node properties:', error);
            return {};
          }
        }

        // Create nodes array from the set with depth information
        console.log('=== Creating nodes array with depth information ===');
        console.log('BOM object structure:', Object.keys(bom_obj));
        console.log('BOM nodes keys:', bom_obj.hasOwnProperty('nodes') ? Object.keys(bom_obj['nodes']).slice(0, 5) : 'No nodes property');
        
        nodes_set.forEach(s => {
          var n = {};
          n["name"] = s;
          n["id"] = s;
          console.log('Creating node with ID:', s);
          n["type"] = "vertex";
          n["adjCount"] = 0;

          // Find the depth and additional attributes for this node from the original data
          n["depth"] = 0; // default depth
          n["attributes"] = {}; // Store additional attributes
          
          console.log(`\n=== SEARCHING FOR NODE: ${s} ===`);
            
            if (bom_obj.hasOwnProperty('nodes')) {
              var node_keys = Object.keys(bom_obj['nodes']);
              const directProperties = ['DrawingID', 'DrawingNumber', 'ItemTag', 'InternalDiameter', 'Subtype', 'Type'];
              
              for (let i = 0; i < node_keys.length; i++) {
                var node_key = node_keys[i];
                var node_data = bom_obj['nodes'][node_key];
                var clean_name = node_data.name || node_key;
                if (clean_name.includes('#')) {
                  clean_name = clean_name.split('#').pop();
                }
                
                console.log(`Checking node_key: ${node_key}, clean_name: ${clean_name}, looking for: ${s}`);
                
                if (clean_name === s) {
                  console.log(`*** FOUND MATCHING NODE DATA FOR ${s} ***`);
                  console.log('Raw node_data:', node_data);
                  console.log('Available keys on node_data:', Object.keys(node_data));
                  
                  if (node_data.depth !== undefined) {
                    n["depth"] = node_data.depth;
                    console.log(`Set depth to ${node_data.depth}`);
                  }
                  
                  // Look for properties directly on the node_data
                  console.log('Checking for direct properties on node_data...');
                  directProperties.forEach(prop => {
                    if (node_data.hasOwnProperty(prop)) {
                      n["attributes"][prop] = node_data[prop];
                      console.log(`FOUND direct property: ${prop} = ${node_data[prop]}`);
                    } else {
                      console.log(`Node ${s}: Direct property ${prop} not found`);
                    }
                  });
                  
                  // Look for properties in a properties sub-object
                  if (node_data.properties) {
                    console.log('Found properties sub-object:', Object.keys(node_data.properties));
                    directProperties.forEach(prop => {
                      if (node_data.properties.hasOwnProperty(prop) && !n["attributes"][prop]) {
                        n["attributes"][prop] = node_data.properties[prop];
                        console.log(`FOUND in properties: ${prop} = ${node_data.properties[prop]}`);
                      }
                    });
                  } else {
                    console.log(`Node ${s}: No properties object found`);
                  }
                  
                  // Look for properties in richDependencies (this is where connection properties are stored)
                  if (node_data.richDependencies) {
                    console.log(`Node ${s}: richDependencies exists with ${node_data.richDependencies.length} items`);
                    
                    // Try to find properties from the first rich dependency as an example
                    if (node_data.richDependencies.length > 0) {
                      console.log(`Node ${s}: RichDep 0:`, node_data.richDependencies[0]);
                      if (node_data.richDependencies[0].properties) {
                        console.log(`Node ${s}: RichDep 0 has properties with keys:`, Object.keys(node_data.richDependencies[0].properties));
                        
                        // Check if this is a connection (has StartNode/EndNode)
                        const richDepProps = node_data.richDependencies[0].properties;
                        if (richDepProps.StartNode || richDepProps.EndNode) {
                          console.log(`Node ${s}: Skipping richDep 0 - has StartNode/EndNode (connection)`);
                        } else {
                          // This might be actual node properties
                          directProperties.forEach(prop => {
                            if (richDepProps.hasOwnProperty(prop) && !n["attributes"][prop]) {
                              n["attributes"][prop] = richDepProps[prop];
                              console.log(`FOUND in richDep properties: ${prop} = ${richDepProps[prop]}`);
                            }
                          });
                        }
                      }
                    }
                  }
                  
                  console.log(`Final attributes for ${s}:`, n["attributes"]);
                  break;
                }
              }
              
              // ENHANCED: If no attributes found in BOM, provide fallback information
              if (Object.keys(n["attributes"]).length === 0) {
                console.log(`*** NO ATTRIBUTES FOUND FOR ${s} IN BOM - using fallback display ***`);
                
                // Try to extract any shared properties from richDependencies (like DrawingNumber)
                if (node_data && node_data.richDependencies && node_data.richDependencies.length > 0) {
                  const firstRichDep = node_data.richDependencies[0];
                  if (firstRichDep.properties) {
                    // Extract common properties that appear in connections
                    if (firstRichDep.properties.DrawingNumber) {
                      n["attributes"]["DrawingNumber"] = firstRichDep.properties.DrawingNumber;
                    }
                    if (firstRichDep.properties.Type) {
                      n["attributes"]["Type"] = firstRichDep.properties.Type;
                    }
                  }
                }
                
                console.log(`Applied fallback attributes for ${s}:`, n["attributes"]);
              }
            }
          
          console.log('Node created:', s, 'with final depth =', n["depth"], 'and attributes:', Object.keys(n["attributes"]));
          nodes.push(n);
        });

        console.log('=== BOM Parsing Summary ===');
        console.log('Total nodes:', nodes.length);
        console.log('Total edges:', edges.length);
        
        // Debug edge connectivity
        console.log('=== Edge Connectivity Debug ===');
        const nodeIds = new Set(nodes.map(n => n.id));
        console.log('Node IDs:', Array.from(nodeIds).slice(0, 5), '... (first 5)');
        
        edges.forEach((edge, i) => {
          if (i < 3) { // Show first 3 edges
            console.log(`Edge ${i}:`, {
              source: edge.source,
              target: edge.target,
              sourceExists: nodeIds.has(edge.source),
              targetExists: nodeIds.has(edge.target)
            });
          }
        });
        
        const missingSources = edges.filter(e => !nodeIds.has(e.source));
        const missingTargets = edges.filter(e => !nodeIds.has(e.target));
        console.log('Edges with missing source nodes:', missingSources.length);
        console.log('Edges with missing target nodes:', missingTargets.length);
        
        if (missingSources.length > 0) {
          console.log('Example missing source:', missingSources[0].source);
        }
        if (missingTargets.length > 0) {
          console.log('Example missing target:', missingTargets[0].target);
        }
        
        // Continue with visualization if we have content
        if (nodes.length > 0 || edges.length > 0) {
          console.log('Proceeding with D3.js visualization');
          
          // Show the wrapper div for visualization
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = 'block';

          /* COMMENTED OUT - OLD VISUALIZATION SETUP THAT CONFLICTS WITH NEW ONE
          // Initial cleanup and setup
          const svg = d3.select("#graph-svg");
          const container = d3.select("#graph-container");
          
          // Clear any existing content
          container.selectAll("*").remove();

          // Get SVG dimensions
          const svgElement = document.getElementById("graph-svg");
          const svgRect = svgElement.getBoundingClientRect();
          const width = svgRect.width;
          const height = svgRect.height;
          
          console.log('SVG dimensions:', width, 'x', height);

          // Initialize the D3.js force simulation
          const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(edges).id(d => d.id).distance(200))
            .force("charge", d3.forceManyBody().strength(-1000))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(40));

          END OF OLD VISUALIZATION SETUP COMMENT */
        } else {
          console.log('No nodes or edges found - hiding visualization');
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = 'none';
        }

        console.log('=== Final node depth summary ===');
        nodes.forEach(node => {
          console.log('Node:', node.name, '-> depth:', node.depth);
        });

        // Generate consistent colors for node types with depth-based intensity
        function getNodeColor(nodeName, depth) {
          // Create a simple hash function for consistent colors
          let hash = 0;
          for (let i = 0; i < nodeName.length; i++) {
            const char = nodeName.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
          }

          // Generate a color based on the hash
          const hue = Math.abs(hash) % 360;

          // Calculate lightness based on depth - 0 is brightest, higher depth is dimmer
          // Start at 70% lightness for depth 0, decrease by 10% per depth level, minimum 20%
          const lightness = Math.max(20, 70 - (depth * 10));

          return `hsl(${hue}, 70%, ${lightness}%)`;
        }

        console.log('Final processing results:');
        console.log('- Nodes count:', nodes.length);
        console.log('- Edges count:', edges.length);
        console.log('- Node names:', nodes.map(n => n.name));
        console.log('- Edge connections:', edges.map(e => e.source + ' -> ' + e.target));

        // Always try to create visualization, even with just nodes
        if (nodes.length > 0) {
          console.log('Starting visualization with', nodes.length, 'nodes and', edges.length, 'edges');
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = '';

          // Clear any existing content including test circle
          d3.select("#graph-svg").selectAll("*").remove();

          // Set up the SVG dimensions
          const svg = d3.select("#graph-svg");
          const width = 800;
          const height = 600;

          svg.attr("viewBox", `0 0 ${width} ${height}`);

          const g = svg.append("g").attr("id", "graph-container");

          console.log("Setting up visualization...");

          // Add arrow marker if we have edges
          if (edges.length > 0) {
            svg.append('defs')
              .append('marker')
              .attr("id", "Triangle")
              .attr("refX", 12)
              .attr("refY", 6)
              .attr("markerUnits", 'userSpaceOnUse')
              .attr("markerWidth", 12)
              .attr("markerHeight", 18)
              .attr("orient", 'auto')
              .append('path')
              .attr("d", 'M 0 0 12 6 0 12 3 6')
              .style("fill", "#666666");
          }

          // Create a copy of nodes and edges for D3
          const graphNodes = nodes.map(d => ({ ...d }));
          const allGraphEdges = edges.map(d => ({
            source: d.source,
            target: d.target,
            weight: d.weight || 1,
            label: d.label || "connects",
            displayLabel: d.displayLabel || "",
            tooltipText: d.tooltipText || "",
            properties: d.properties || {},
            type: d.type || "connection",
            itemTag: d.itemTag || "",
            nominalDiameter: d.nominalDiameter || "",
            flowDir: d.flowDir || "",
            drawingNumber: d.drawingNumber || ""
          }));

          // Deduplicate edges - only keep one edge per unique source-target pair
          const edgeMap = new Map();
          allGraphEdges.forEach(edge => {
            // Simple key: just source-target, no bidirectional deduplication
            const key = `${edge.source}-${edge.target}`;
            
            // Only add if this exact source->target doesn't exist yet
            if (!edgeMap.has(key)) {
              edgeMap.set(key, edge);
            }
          });
          
          // Use the deduplicated edges
          const graphEdges = Array.from(edgeMap.values());

          console.log("Graph nodes for D3:", graphNodes);
          console.log("Graph edges for D3 (deduplicated):", graphEdges);
          console.log("Original edges count:", allGraphEdges.length, "Deduplicated count:", graphEdges.length);
          
          // Debug: Check edge source/target types
          if (graphEdges.length > 0) {
            console.log("First edge source type:", typeof graphEdges[0].source, "value:", graphEdges[0].source);
            console.log("First edge target type:", typeof graphEdges[0].target, "value:", graphEdges[0].target);
          }
          
          // Debug: Log edge source-target pairs to check for duplicates
          const edgePairs = graphEdges.map(e => `${e.source} → ${e.target} (${e.displayLabel || e.label})`);
          console.log("Final edge pairs:", edgePairs);

          // Set up the simulation
          const simulation = d3.forceSimulation(graphNodes)
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(20));

          // Add link force only if we have edges
          if (graphEdges.length > 0) {
            simulation.force("link", d3.forceLink(graphEdges).id(d => d.id).distance(100));
          }

          // Create links only if we have edges
          let link = null;
          let linkLabels = null;
          if (graphEdges.length > 0) {
            link = g.append("g")
              .attr("class", "links")
              .selectAll("line")
              .data(graphEdges)
              .enter().append("line")
              .attr("class", "link")
              .style("stroke", "#666666")
              .style("stroke-width", 2)
              .attr("marker-end", "url(#Triangle)");

            // Add tooltips to edges showing rich dependency information
            link.append("title")
              .text(d => {
                // Use short displayLabel for cleaner tooltips
                if (d.displayLabel && d.displayLabel !== "") {
                  return d.displayLabel;
                } else if (d.edgeLabel && d.edgeLabel !== "") {
                  return d.edgeLabel;
                } else {
                  // Fallback to simple connection label
                  return `${d.source} → ${d.target}`;
                }
              });

            // Add labels to edges with proper angle alignment
            linkLabels = g.append("g")
              .attr("class", "link-labels")
              .selectAll("text")
              .data(graphEdges)
              .enter().append("text")
              .attr("class", "link-label")
              .style("font-size", "8px")
              .style("fill", "#4a5568")
              .style("text-anchor", "middle")
              .style("pointer-events", "none")
              .style("text-shadow", "none")
              .text(d => {
                // Extract clean connection type without arrows or prefixes
                if (d.displayLabel && d.displayLabel !== "") {
                  // Remove arrows and clean up the label
                  return d.displayLabel.replace(/[←→↔]/g, '').trim();
                } else if (d.label && d.label !== "depends on" && d.label !== "connects") {
                  return d.label.replace(/[←→↔]/g, '').trim();
                } else if (d.type && d.type !== "connection") {
                  return d.type;
                } else {
                  return "Connection";
                }
              });
          }

          // Create nodes
          const node = g.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(graphNodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended));

          // Add circles to nodes
          node.append("circle")
            .attr("r", 6)
            .style("fill", d => getNodeColor(d.name, d.depth))
            .style("stroke", "none");

          // Add labels to nodes - multi-line with attributes
          const nodeLabels = node.append("text")
            .style("font-size", "10px")
            .style("text-anchor", "start") // Left-align text to start right of circle
            .attr("dx", "8") // Position 8 pixels to the right of circle center
            .attr("dy", "-0.5em") // Start slightly above center for multi-line
            .style("fill", "white")
            .style("text-shadow", "none");

          nodeLabels.each(function(d) {
            const textElement = d3.select(this);
            const lines = [];
            
            // First line: Node name (more generous truncation)
            const displayName = d.name.length > 32 ? d.name.substring(0, 32) + '...' : d.name;
            lines.push({ text: displayName, opacity: 1.0 });
            
            // Add up to 3 additional attribute lines (just values, no keys)
            if (d.attributes && Object.keys(d.attributes).length > 0) {
              const attrKeys = Object.keys(d.attributes);
              const interestingAttributes = ["ItemTag", "DrawingNumber", "DrawingID", "Type", "Subtype", "InternalDiameter", "TagPrefix", "TagSequenceNo"];
              
              // Prioritize TTL-based attributes first, then add others
              const sortedKeys = [...attrKeys].sort((a, b) => {
                const aIndex = interestingAttributes.indexOf(a);
                const bIndex = interestingAttributes.indexOf(b);
                if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                if (aIndex !== -1) return -1;
                if (bIndex !== -1) return 1;
                return a.localeCompare(b);
              });
              
              // Take up to 3 attributes
              for (let i = 0; i < Math.min(3, sortedKeys.length); i++) {
                const key = sortedKeys[i];
                const value = d.attributes[key];
                if (value && value.toString().trim() !== "") {
                  let displayValue = value.toString();
                  
                  // For key TTL properties, show them cleanly
                  if (["ItemTag", "DrawingNumber", "DrawingID", "InternalDiameter"].includes(key)) {
                    displayValue = displayValue.length > 25 ? displayValue.substring(0, 25) + '...' : displayValue;
                  }
                  // For other properties, add the key prefix if value is short
                  else if (displayValue.length < 10) {
                    displayValue = `${key}: ${displayValue}`;
                  }
                  // Only truncate if really long (> 25 chars)
                  else if (displayValue.length > 25) {
                    displayValue = displayValue.substring(0, 25) + '...';
                  }
                  
                  // Each line gets progressively dimmer: 1.0, 0.8, 0.6, 0.4
                  const opacity = 1.0 - ((i + 1) * 0.2);
                  lines.push({ text: displayValue, opacity: opacity });
                }
              }
            }
            
            // Create tspan elements for each line
            lines.forEach((line, index) => {
              textElement.append("tspan")
                .attr("x", 8) // Keep consistent x position
                .attr("dy", index === 0 ? "0" : "1.1em") // Line spacing
                .style("font-weight", index === 0 ? "bold" : "normal")
                .style("font-size", index === 0 ? "10px" : "9px") // Slightly smaller for attributes
                .style("opacity", line.opacity) // Progressive dimming
                .text(line.text);
            });
          });

          // Add zoom behavior
          const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", function (event) {
              g.attr("transform", event.transform);
            });

          svg.call(zoom);

          // Update positions on tick
          simulation.on("tick", function () {
            if (link) {
              link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            }

            if (linkLabels) {
              linkLabels
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2)
                .attr("dy", "0.35em") // Center the text vertically
                .attr("transform", d => {
                  // Calculate angle of the line for text rotation
                  const dx = d.target.x - d.source.x;
                  const dy = d.target.y - d.source.y;
                  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                  const x = (d.source.x + d.target.x) / 2;
                  const y = (d.source.y + d.target.y) / 2;
                  
                  // Ensure text is always readable (not upside down)
                  const rotationAngle = (angle > 90 || angle < -90) ? angle + 180 : angle;
                  
                  // Position the text slightly above the line (in the rotated coordinate system)
                  const offsetY = -5; // 5 pixels above the line
                  return `rotate(${rotationAngle}, ${x}, ${y}) translate(0, ${offsetY})`;
                });
            }

            node
              .attr("transform", d => `translate(${d.x},${d.y})`);
          });

          // Drag functions
          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }

          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }

          // Add click handlers
          node.on("click", function (event, d) {
            console.log("Clicked node:", d.name);
          });

          console.log("Visualization setup complete");
        } else {
          console.log('No nodes found to visualize');
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = 'none';
        }
      } catch (e) {
        console.error('Error parsing BOM JSON:', e);
        console.log('Error details:', e.message);
        console.log('JSON content that failed:', bom_json.substring(0, 500));

        // Show detailed error message in visualization
        // Keep visualization hidden on parse errors
        const wrapper = document.getElementById('viz_wrapper');
        if (wrapper) wrapper.style.display = 'none';
      }
    } else {
      console.log('No BOM data found - element content is empty');
      // Keep hidden when there's no data
      const wrapper = document.getElementById('viz_wrapper');
      if (wrapper) wrapper.style.display = 'none';
    }
  });
</script>
{% endblock %}