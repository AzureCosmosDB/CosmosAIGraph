{% extends "layout.html" %}
{% block title %} SPARQL Console {% endblock %}

{% block content %}
<style>
  /* Style for edge labels - D3.js specific */
  .link-label {
    font-family: "Lucida Console", "Courier New", monospace !important;
    text-shadow: none !important;
  }

  /* Style for node labels - D3.js specific */
  .node text {
    text-shadow: none !important;
    font-family: "Lucida Console", "Courier New", monospace !important;
  }

  /* General D3 visualization font override */
  #d3viz text {
    font-family: "Lucida Console", "Courier New", monospace !important;
  }

  /* Remove all padding from caig-inner-body - page specific */
  .caig-inner-body {
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }

  /* Remove white border from CodeMirror editors */
  .CodeMirror {
    border: none !important;
  }
  
  .CodeMirror-focused {
    border: none !important;
    outline: none !important;
  }

</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/theme/tomorrow-night-eighties.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>

<div class="container">
  <h5>SPARQL Playground</h5>
  <p></p>
  <div class="card caig-card" style="width: 100%;">
    <div class="card-body bg-dark text-light caig-inner-body">
      <form method="post" id="form" name="form">
        <div class="mb-3">
          <label for="sparql" class="form-label">SPARQL query:</label>
          <textarea rows='8' class="form-control" id="sparql" name="sparql" value="{{ sparql }}">{{ sparql }}</textarea>
          <script>
            var editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
              mode: "sparql",
              lineNumbers: true,
              theme: "tomorrow-night-eighties"
            });
            function resizeCodeMirrorToContent(cm) {
              var doc = cm.getDoc();
              var lineCount = doc.lineCount();
              var newHeight = Math.max((lineCount + 1) * 24, 120); // Minimum height of 120px (5 lines)
              cm.setSize(null, newHeight + "px");
            }
            resizeCodeMirrorToContent(editor);
            editor.on("change", function (cm) {
              resizeCodeMirrorToContent(cm);
            });
          </script>
        </div>
        <div class="mb-3">
          <button type="button" id="sparql_submit_button" name="sparql_submit_button"
            class="btn btn-outline-primary mb-3">Execute SPARQL</button>
        </div>
        <div class="mb-3">
          <label for="bom_query" class="form-label">Entity name, space and dependency depth:</label>
          <div class="d-flex gap-2">
            <input type="text" class="form-control" id="bom_query" name="bom_query" value="{{ bom_query }}"
              placeholder="<Entity ID/name> <Depth>"></input>
            <button type="button" id="entity_submit_button" name="entity_submit_button"
              class="btn btn-outline-primary" style="white-space: nowrap;">Visualize Graph</button>
          </div>
        </div>
        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
    </div>
    <div id="viz_wrapper" class="container-fluid p-0" style="display:none;">
      <div class="d-flex justify-content-between align-items-center" style="padding: 8px 12px;">
        <h5 class="mb-0">{{ visualization_message }}</h5>
        <div class="btn-group btn-group-sm" role="group" aria-label="Visualization toggles">
          <input type="checkbox" class="btn-check" id="toggle-link-labels" checked>
          <label class="btn btn-outline-secondary" for="toggle-link-labels">Link Labels</label>

          <input type="checkbox" class="btn-check" id="toggle-node-attributes" checked>
          <label class="btn btn-outline-secondary" for="toggle-node-attributes">Node Details</label>
        </div>
      </div>
      <div class="bg-dark" id="d3viz" name="d3viz" style="width:100%; height:800px; overflow:auto;" data-debug="true">
        <svg id="graph-svg" style="width:100%; height:100%; display:block;" preserveAspectRatio="xMidYMid meet">
          <g id="graph-container"></g>
        </svg>
      </div>
      <div style="display: none;" id="inline_bom_json" name="inline_bom_json">
        {{ inline_bom_json }}
      </div>
    </div>   
    <div class="container" id="results_div" name="results_div">
      {% set computed_count = count if count else 0 %}
      {% if (not computed_count) and results %}
      {# SPARQL (Apache Jena) JSON shape: results -> { head, results: { bindings: [...] } } #}
      {% if results.results is defined and results.results.results is defined and results.results.results.bindings is
      defined %}
      {% set computed_count = results.results.results.bindings | length %}
      {% elif results.results is defined and results.results.bindings is defined %}
      {% set computed_count = results.results.bindings | length %}
      {% elif results.nodes is defined %}
      {% set computed_count = results.nodes | length %}
      {% elif results.libs is defined %}
      {% set computed_count = results.libs | length %}
      {% endif %}
      {% endif %}

      <div class="d-flex justify-content-between align-items-center" style="padding: 8px 0;">
        <h5>{{ results_message}}</h5>
        <div class="d-flex align-items-center gap-3">
          {% if computed_count and computed_count > 0 %}
          <h6 class="text-muted mb-0">Total: {{ computed_count }}</h6>
          {% elif results %}
          <h6 class="text-muted mb-0">Results returned (count not provided)</h6>
          {% endif %}
          {% if results %}
          <button type="button" class="btn btn-outline-secondary btn-sm" id="toggle-results-btn">
            <span id="toggle-results-text">Hide</span>
            <span id="toggle-results-icon">‚ñ≤</span>
          </button>
          {% endif %}
        </div>
      </div>
      {% if results %}
      <div id="results-content">
        <!-- Check if results contain an error -->
        {% if results.error %}
        <div class="alert alert-danger" role="alert">
          <h6 class="alert-heading">
            <i class="bi bi-exclamation-triangle-fill"></i> 
            {% if "timeout" in results.error.lower() %}
              Request Timeout
            {% elif "connect" in results.error.lower() %}
              Connection Error  
            {% elif "http" in results.error.lower() %}
              Service Error
            {% else %}
              Processing Error
            {% endif %}
          </h6>
          <p class="mb-0">{{ results.error }}</p>
          {% if "timeout" in results.error.lower() %}
          <hr>
          <p class="mb-0 small">
            <strong>Tips:</strong> Try reducing the depth parameter, using a more specific entity name, or running the query during off-peak hours.
          </p>
          {% elif "connect" in results.error.lower() %}
          <hr>
          <p class="mb-0 small">
            <strong>Solution:</strong> Please contact the system administrator to ensure the graph microservice is running and accessible.
          </p>
          {% endif %}
        </div>
        {% else %}
        <!-- Normal results display -->
        <div id="results-data" style="display: none;">{{ results | tojson | safe }}</div>
        <div id="results-formatted"></div>
        {% endif %}
      </div>
      {% endif %}
      <!-- Prism.js resources will be loaded dynamically when needed -->
    </div>


  </div>
</div>

{% endblock %}

{% block js %}
<script>
  console.log('Script block started');
  console.log('D3 available:', typeof d3 !== 'undefined');
  console.log('jQuery available:', typeof $ !== 'undefined');

  const form = document.getElementById("form");
  const sparql_submit_button = document.getElementById("sparql_submit_button");
  const entity_submit_button = document.getElementById("entity_submit_button");
  const bom_query = document.getElementById("bom_query");

  // Function to check if Visualize Graph button should be enabled
  function updateVisualizeBtnState() {
    const value = bom_query.value.trim();
    // Disable if empty or contains only placeholder-like content
    const isEmpty = value === "" || value === "<Entity ID/name> <Depth>";
    entity_submit_button.disabled = isEmpty;
    if (isEmpty) {
      entity_submit_button.classList.add("disabled");
    } else {
      entity_submit_button.classList.remove("disabled");
    }
  }

  // Check initial state
  updateVisualizeBtnState();

  // Add event listener to update button state when input changes
  bom_query.addEventListener('input', updateVisualizeBtnState);
  bom_query.addEventListener('change', updateVisualizeBtnState);

  // SPARQL submit button - clears entity field and submits with SPARQL query
  sparql_submit_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      // Clear the entity field to ensure SPARQL query takes precedence
      const bom_query = document.getElementById("bom_query");
      bom_query.value = "";
      
      // Show loading indicator
      const errorMsg = document.getElementById("error_message");
      if (errorMsg) {
        errorMsg.innerHTML = '<div class="text-info"><i class="bi bi-hourglass-split"></i> Executing SPARQL query...</div>';
      }
      
      sparql_submit_button.disabled = true;
      entity_submit_button.disabled = true;
      sparql_submit_button.textContent = "Processing...";
      form.submit();
    }
  );

  // Entity submit button - clears SPARQL field and submits with entity query
  entity_submit_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      
      // Don't proceed if button is disabled
      if (entity_submit_button.disabled) {
        return;
      }
      
      // Update CodeMirror content to form field and then clear it
      if (typeof editor !== 'undefined') {
        editor.save(); // Sync CodeMirror content to textarea
      }
      const sparql_field = document.getElementById("sparql");
      sparql_field.value = "";
      
      // Show loading indicator
      const errorMsg = document.getElementById("error_message");
      if (errorMsg) {
        errorMsg.innerHTML = '<div class="text-info"><i class="bi bi-hourglass-split"></i> Processing graph visualization... This may take a moment for large graphs.</div>';
      }
      
      sparql_submit_button.disabled = true;
      entity_submit_button.disabled = true;
      entity_submit_button.textContent = "Processing...";
      form.submit();
    }
  );

  // Use regular DOM ready instead of jQuery if it's not available
  function domReady(fn) {
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(fn, 1);
    } else {
      document.addEventListener("DOMContentLoaded", fn);
    }
  }

  domReady(function () {
    console.log('DOM ready, starting processing');

    // Performance: debug gating and render scheduler
    const DEBUG = (document.getElementById('d3viz') && document.getElementById('d3viz').dataset.debug === 'true');
    // If not debugging, make console.noop to reduce overhead of excessive logging
    if (!DEBUG) {
      console.log = function() {};
      console.debug = function() {};
      console.info = function() {};
      console.warn = function() {};
    }

    // Render scheduler to batch DOM updates via requestAnimationFrame
    let __renderRequested = false;
    function scheduleRender() {
      if (!__renderRequested) {
        __renderRequested = true;
        requestAnimationFrame(() => {
          __renderRequested = false;
          try {
            if (typeof window.__updatePositions === 'function') {
              window.__updatePositions();
            } else {
              // Fallback immediate updates if __updatePositions not present
              if (typeof link !== 'undefined' && link) {
                link
                  .attr('x1', d => d.source.x)
                  .attr('y1', d => d.source.y)
                  .attr('x2', d => d.target.x)
                  .attr('y2', d => d.target.y);
              }
              if (typeof linkLabels !== 'undefined' && linkLabels) {
                linkLabels
                  .attr('x', d => (d.source.x + d.target.x) / 2)
                  .attr('y', d => (d.source.y + d.target.y) / 2)
                  .attr('transform', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    const cx = (d.source.x + d.target.x) / 2;
                    const cy = (d.source.y + d.target.y) / 2;
                    const rot = (angle > 90 || angle < -90) ? angle + 180 : angle;
                    return `rotate(${rot}, ${cx}, ${cy}) translate(0,-5)`;
                  });
              }
              if (typeof node !== 'undefined' && node) {
                node.attr('transform', d => `translate(${d.x},${d.y})`);
              }
            }
          } catch (err) {
            console.warn('render error', err);
          }
        });
      }
    }

    var method = "{{ method }}";
    var libtype = "{{ libtype }}";
    var libtype_prefix_idx = libtype.length + 1;

    // Helper function to generate consistent colors for nodes
    function getNodeColor(nodeName, depth) {
      // Create a simple hash function for consistent colors
      let hash = 0;
      for (let i = 0; i < nodeName.length; i++) {
        const char = nodeName.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }

      // Generate a color based on the hash
      const hue = Math.abs(hash) % 360;

      // Calculate lightness based on depth - 0 is brightest, higher depth is dimmer
      // Start at 70% lightness for depth 0, decrease by 10% per depth level, minimum 20%
      const lightness = Math.max(20, 70 - (depth * 10));

      return `hsl(${hue}, 70%, ${lightness}%)`;
    }

    // Test basic D3 functionality
    console.log('Testing D3.js...');
    console.log('Window.d3:', typeof window.d3);
    console.log('Global d3:', typeof d3);
    
    // Check if D3 is available
    if (typeof d3 === 'undefined') {
      console.error('D3.js is not loaded! Cannot proceed with visualization.');
      const wrapper = document.getElementById('viz_wrapper');
      if (wrapper) wrapper.style.display = 'none';
      return;
    }
    
    try {
      d3.select("#graph-svg")
        .append("circle")
        .attr("cx", 50)
        .attr("cy", 50)
        .attr("r", 10)
        .style("fill", "green");
      console.log('D3 test circle added successfully');
    } catch (e) {
      console.error('D3 test failed:', e);
      return;
    }

    // Get the Bill-of-Materials (BOM) data that is embedded in the page.
    var bomElement = document.getElementById("inline_bom_json");
    console.log('BOM element found:', !!bomElement);

    if (!bomElement) {
      console.error('inline_bom_json element not found');
      // Keep visualization hidden when there is nothing to render
      const wrapper = document.getElementById('viz_wrapper');
      if (wrapper) wrapper.style.display = 'none';
      return;
    }

    var bom_json = bomElement.innerHTML.trim();
    console.log('Raw BOM JSON length:', bom_json.length);
    console.log('Raw BOM JSON first 300 chars:', bom_json.substring(0, 300));

    // Show the raw content in the SVG for debugging
    // Do not show any preview text when hidden
    d3.select("#graph-svg").selectAll("*").remove();

    if (bom_json && bom_json.trim() !== '') {
      // Trim only; avoid global single-quote replace which corrupts non-JSON text
      bom_json = bom_json.trim();

      console.log('Trimmed BOM content first 500 chars:', bom_json.substring(0, 500));

      // Convert Python dictionary format to valid JSON using eval in a safe context
      function convertPythonDictToJson(pythonStr) {
        console.log('Converting Python dict to JSON using safe evaluation...');
        
        try {
          // Create a safe evaluation context that converts Python literals to JavaScript
          const pythonToJs = pythonStr
            .replaceAll('None', 'null')
            .replaceAll('False', 'false')
            .replaceAll('True', 'true');
          
          // Use Function constructor instead of eval for safer execution
          const jsObject = (new Function('return ' + pythonToJs))();
          
          // Convert back to JSON string
          const jsonString = JSON.stringify(jsObject);
          console.log('Python to JSON conversion completed successfully');
          return jsonString;
          
        } catch (error) {
          console.warn('Safe evaluation failed, falling back to regex conversion:', error);
          
          // Fallback to regex-based conversion
          let s = pythonStr
            .replaceAll(': None', ': null')
            .replaceAll(':None', ':null')
            .replaceAll(': False', ': false')
            .replaceAll(':False', ':false')
            .replaceAll(': True', ': true')
            .replaceAll(':True', ':true');
          
          // Replace single quotes with double quotes more carefully
          // This regex targets single quotes that are likely to be string delimiters
          s = s.replace(/'([^'\\]*(\\.[^'\\]*)*)'/g, '"$1"');
          
          console.log('Regex-based Python to JSON conversion completed');
          return s;
        }
      }

      // Safer BOM JSON parser: detect non-JSON (TTL/plain text) and avoid eval fallback
      function tolerantParseBom(raw) {
        const original = raw;
        let s = (raw || '').trim();

        // Quick heuristic: JSON must start with { or [ after trimming
        if (!(s.startsWith('{') || s.startsWith('['))) {
          // Detect likely TTL or other non-JSON artifacts
          const ttlIndicators = ['@prefix', '@base', 'a :', 'PREFIX ', 'rule "', 'attributeDefinitionRule', 'attributeDescription', ':attributeDefinitionRule', 'ontology', 'rdf:'];
          for (const ind of ttlIndicators) {
            if (s.includes(ind)) {
              console.error('tolerantParseBom: content appears to be TTL or non-JSON; abort parse. Indicator:', ind);
              throw new SyntaxError('BOM content is not JSON (looks like TTL or plain text).');
            }
          }

          // Try to extract a JSON-looking substring between the first { and last }
          const firstBrace = s.indexOf('{');
          const lastBrace = s.lastIndexOf('}');
          if (firstBrace === -1 || lastBrace === -1 || lastBrace <= firstBrace) {
            throw new SyntaxError('BOM content does not contain a JSON object.');
          }
          s = s.substring(firstBrace, lastBrace + 1);
        }

        // Convert Python dictionary format to JSON
        s = convertPythonDictToJson(s);

        // Try strict JSON.parse first
        try {
          return JSON.parse(s);
        } catch (e1) {
          console.warn('tolerantParseBom: JSON.parse failed', e1);
        }

        // Controlled repair: replace standalone single-quoted strings with double-quoted strings
        try {
          const repaired = s.replace(/'([^']*)'/g, function(match, p1) {
            // Escape any double quotes inside
            const escaped = p1.replace(/"/g, '\\"');
            return '"' + escaped + '"';
          });
          return JSON.parse(repaired);
        } catch (e2) {
          console.error('tolerantParseBom: reparsed JSON failed', e2);
          console.error('Original BOM snippet:', (original || '').substring(0, 1000));
          throw e2;
        }
      }

      try {
        var bom_obj = tolerantParseBom(bom_json);
        console.log('BOM data parsed successfully');
        console.log('BOM object keys:', Object.keys(bom_obj));
        
        // Check if the BOM object contains an error (handle both null and None)
        if (bom_obj.hasOwnProperty('error') && bom_obj.error !== null && bom_obj.error !== undefined) {
          console.log('BOM object contains error:', bom_obj.error);
          // Hide visualization on error - error will be shown in results section
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = 'none';
          return;
        }
        
        // Clear any debug info; we'll render only if nodes exist
        d3.select("#graph-svg").selectAll("*").remove();

        // Transform the BOM data into a structure that is usable by D3.js to render the graph.
        var nodes = Array();
        var edges = Array();
        var nodes_set = new Set();

        // Handle the new JSON structure with 'nodes' property
        if (bom_obj.hasOwnProperty('nodes')) {
          console.log('Found nodes property with', Object.keys(bom_obj.nodes).length, 'entries');
          var bom_nodes = bom_obj['nodes'];
          var node_keys = Object.keys(bom_nodes);

          for (let i = 0; i < node_keys.length; i++) {
            var node_key = node_keys[i];
            var node_data = bom_nodes[node_key];

            // Extract clean node name (remove URI prefix if present)
            var clean_name = node_data.name || node_key;
            if (clean_name.includes('#')) {
              clean_name = clean_name.split('#').pop();
            }

            console.log('Processing node:', clean_name, 'with dependencies:', node_data.dependencies);
            console.log('Adding to nodes_set:', clean_name);
            nodes_set.add(clean_name);

            // Process rich dependencies if available (new enhanced format)
            var richDependencies = node_data.richDependencies;
            if (Array.isArray(richDependencies) && richDependencies.length > 0) {
              console.log('Found rich dependencies:', richDependencies.length);
              
              for (let d = 0; d < richDependencies.length; d++) {
                var richDep = richDependencies[d];
                var dep_uri = richDep.uri;
                var dep_clean_name = richDep.name || dep_uri;

                // Clean up dependency name (remove URI prefix if present)
                if (typeof dep_clean_name === 'string' && dep_clean_name.includes('#')) {
                  dep_clean_name = dep_clean_name.split('#').pop();
                }

                // Create edges with rich information
                if (dep_clean_name !== clean_name &&
                  dep_clean_name.length > 0 &&
                  dep_clean_name.trim() !== '') {

                  console.log('Creating rich edge:', clean_name, '->', dep_clean_name, 'with properties:', richDep.properties);
                  nodes_set.add(dep_clean_name);

                  var edge = {};
                  edge["source"] = clean_name;
                  edge["target"] = dep_clean_name;
                  console.log('Creating edge:', clean_name, '->', dep_clean_name);
                  edge["weight"] = 1.0;
                  
                  // Use rich dependency data for meaningful edge labels
                  edge["label"] = richDep.edgeLabel || "connects";
                  edge["displayLabel"] = richDep.displayLabel || dep_clean_name;
                  edge["tooltipText"] = richDep.tooltipText || "";
                  edge["properties"] = richDep.properties || {};
                  edge["type"] = richDep.type || "connection";
                  edge["isLateralConnection"] = richDep.isLateralConnection || false;
                  
                  // Extract specific engineering properties for enhanced visualization
                  if (richDep.properties) {
                    edge["itemTag"] = richDep.properties.ItemTag || "";
                    edge["nominalDiameter"] = richDep.properties.NominalDiameter || "";
                    edge["flowDir"] = richDep.properties.FlowDir || "";
                    edge["drawingNumber"] = richDep.properties.DrawingNumber || "";
                  }
                  
                  edges.push(edge);
                }
              }
            }
            // Fallback to legacy dependencies if no rich dependencies available
            else {
              var dependencies = node_data.dependencies;
              if (Array.isArray(dependencies)) {
                console.log('Using legacy dependencies format');
                
                for (let d = 0; d < dependencies.length; d++) {
                  var dep_uri = dependencies[d];
                  var dep_clean_name = dep_uri;

                  // Clean up dependency name (remove URI prefix if present)
                  if (typeof dep_uri === 'string' && dep_uri.includes('#')) {
                    dep_clean_name = dep_uri.split('#').pop();
                  }

                  // Create edges for all meaningful dependencies
                  // Only skip exact self-references and empty strings
                  if (dep_clean_name !== clean_name &&
                    dep_clean_name.length > 0 &&
                    dep_clean_name.trim() !== '') {

                    console.log('Creating legacy edge:', clean_name, '->', dep_clean_name);
                    nodes_set.add(dep_clean_name);

                    var edge = {};
                    edge["source"] = clean_name;
                    edge["target"] = dep_clean_name;
                    edge["weight"] = 1.0;
                    edge["label"] = "depends on";
                    edges.push(edge);
                  }
                }
              }
            }
          }
        }
        // Fallback: Handle legacy 'libs' structure for backwards compatibility
        else if (bom_obj.hasOwnProperty('libs')) {
          console.log('Found libs property - using legacy format');
          var bom_libs = bom_obj['libs'];
          var lib_keys = Object.keys(bom_libs);

          for (let i = 0; i < lib_keys.length; i++) {
            var lib_key = lib_keys[i];
            var lib_key_tokens = lib_key.split("#");
            var lib_key_no_prefix = lib_key_tokens[1] || lib_key;
            nodes_set.add(lib_key_no_prefix);

            var dep_libs = bom_libs[lib_key]["dependencies"];
            if (Array.isArray(dep_libs)) {
              for (let d = 0; d < dep_libs.length; d++) {
                var dep_lib_uri = dep_libs[d];
                var dep_lib_uri_tokens = dep_lib_uri.split("#");
                var dep_lib_no_prefix = dep_lib_uri_tokens[1] || dep_lib_uri;
                nodes_set.add(dep_lib_no_prefix);

                var edge = {};
                edge["source"] = lib_key_no_prefix;
                edge["target"] = dep_lib_no_prefix;
                edge["weight"] = 1.0;
                edge["label"] = "depends on";
                edges.push(edge);
              }
            }
          }
        } else {
          console.log('No recognized data structure found. Available keys:', Object.keys(bom_obj));
        }

        // Function to fetch node properties using SPARQL
        async function fetchNodeProperties(nodeId) {
          try {
            console.log(`Fetching properties for node: ${nodeId}`);
            
            // Create SPARQL query to get node properties
            const sparqlQuery = `
              PREFIX owl: <http://www.w3.org/2002/07/owl#>
              PREFIX schema: <http://schema.org/ontology#>
              SELECT ?property ?value WHERE {
                <http://schema.org/ontology#${nodeId}> ?property ?value .
                FILTER(?property != <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>)
              }
            `;
            
            console.log('SPARQL query for node properties:', sparqlQuery);
            
            // Post SPARQL query to the backend
            const response = await fetch('/sparql_console', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body: new URLSearchParams({
                'sparql': sparqlQuery,
                'bom_query': ''
              })
            });
            
            if (!response.ok) {
              console.error('Failed to fetch node properties:', response.status);
              return {};
            }
            
            const responseText = await response.text();
            console.log('Raw SPARQL response for node properties:', responseText.substring(0, 500));
            
            // Parse the response to extract properties
            // This is a simplified parser - in production you'd want more robust parsing
            const properties = {};
            
            try {
              // Try to extract JSON from the response
              const jsonMatch = responseText.match(/"results":\s*{[^}]*"bindings":\s*\[([^\]]*)\]/);
              if (jsonMatch) {
                const bindingsText = jsonMatch[1];
                console.log('Bindings text:', bindingsText);
                
                // Parse individual bindings
                const bindingMatches = bindingsText.match(/{[^}]*}/g);
                if (bindingMatches) {
                  bindingMatches.forEach(binding => {
                    const propMatch = binding.match(/"property":\s*{\s*"value":\s*"([^"]*)".*?"value":\s*{\s*"value":\s*"([^"]*)"/);
                    if (propMatch) {
                      const propUri = propMatch[1];
                      const propValue = propMatch[2];
                      
                      // Extract property name from URI
                      let propName = propUri;
                      if (propUri.includes('#')) {
                        propName = propUri.split('#').pop();
                      }
                      
                      properties[propName] = propValue;
                      console.log(`Extracted property: ${propName} = ${propValue}`);
                    }
                  });
                }
              }
            } catch (parseError) {
              console.error('Error parsing SPARQL response:', parseError);
            }
            
            console.log('Final extracted properties for', nodeId, ':', properties);
            return properties;
            
          } catch (error) {
            console.error('Error fetching node properties:', error);
            return {};
          }
        }

        // Create nodes array from the set with depth information
        console.log('=== Creating nodes array with depth information ===');
        console.log('BOM object structure:', Object.keys(bom_obj));
        
        // First, let's examine the actual structure of the BOM data
        if (bom_obj.hasOwnProperty('nodes')) {
          const firstNodeKey = Object.keys(bom_obj['nodes'])[0];
          if (firstNodeKey) {
            console.log('Sample node from BOM:', firstNodeKey, '=', bom_obj['nodes'][firstNodeKey]);
          }
        }
        
        // Create a map of all node data from bom_obj for easy lookup
        const nodeDataMap = new Map();
        
        if (bom_obj.hasOwnProperty('nodes')) {
          const bomNodes = bom_obj['nodes'];
          Object.keys(bomNodes).forEach(nodeKey => {
            const nodeData = bomNodes[nodeKey];
            
            // The node key might be the full URI
            let cleanName = nodeKey;
            if (nodeKey.includes('#')) {
              cleanName = nodeKey.split('#').pop();
            }
            
            // Also check if there's a name property
            if (nodeData.name) {
              let nodeName = nodeData.name;
              if (nodeName.includes('#')) {
                nodeName = nodeName.split('#').pop();
              }
              // Use the name from the property if different
              if (nodeName !== cleanName) {
                nodeDataMap.set(nodeName, nodeData);
              }
            }
            
            console.log(`Storing node data for ${cleanName}:`, {
              hasProperties: !!nodeData.properties,
              propertyCount: nodeData.properties ? Object.keys(nodeData.properties).length : 0,
              properties: nodeData.properties,
              fullData: nodeData
            });
            
            nodeDataMap.set(cleanName, nodeData);
          });
        }
        
        console.log('Node data map size:', nodeDataMap.size);
        console.log('Node data map keys:', Array.from(nodeDataMap.keys()).slice(0, 5));
        
        nodes_set.forEach(s => {
          var n = {};
          n["name"] = s;
          n["id"] = s;
          console.log('\nCreating node with ID:', s);
          n["type"] = "vertex";
          n["adjCount"] = 0;
          n["depth"] = 0; // default depth
          n["attributes"] = {}; // Store additional attributes
          
          console.log(`=== SEARCHING FOR NODE: ${s} ===`);
          
          // Look up node data from our map
          const nodeData = nodeDataMap.get(s);
          
          if (nodeData) {
            console.log(`*** FOUND MATCHING NODE DATA FOR ${s} ***`);
            console.log('Raw node_data:', JSON.stringify(nodeData, null, 2));
            
            // Set depth if available
            if (nodeData.depth !== undefined) {
              n["depth"] = nodeData.depth;
            }
            
            // Extract properties - handle different possible structures
            let properties = {};
            
            // Check for properties object
            if (nodeData.properties && typeof nodeData.properties === 'object') {
              properties = nodeData.properties;
              console.log('Found properties object:', Object.keys(properties));
            }
            // Check if properties are at the root level of nodeData
            else {
              console.log('No properties object, checking root level attributes');
              // Copy all non-standard fields as properties
              Object.keys(nodeData).forEach(key => {
                if (!['name', 'depth', 'dependencies', 'richDependencies', 'uri'].includes(key)) {
                  properties[key] = nodeData[key];
                }
              });
              
              if (Object.keys(properties).length > 0) {
                console.log('Found root-level properties:', Object.keys(properties));
              }
            }
            
            // Filter and add properties as attributes
            Object.keys(properties).forEach(prop => {
              // Filter out edge-related properties
              const edgeProps = ['StartNode', 'EndNode', 'DirectConnection', 'Piping', 'Signal', 
                                'ConnectToProcess', 'Edge', 'connection', 'depends on', 
                                'source', 'target', 'weight', 'label'];
              const isEdgeType = edgeProps.includes(prop) || 
                                prop.includes('Connection') || 
                                prop === 'Piping' || 
                                prop === 'Signal' ||
                                prop === 'ConnectToProcess';
              
              if (!isEdgeType) {
                n["attributes"][prop] = properties[prop];
                console.log(`Added property: ${prop} = ${properties[prop]}`);
              } else {
                console.log(`Filtered out edge-related property: ${prop}`);
              }
            });
            
            console.log(`Final attributes for ${s}:`, n["attributes"]);
            console.log(`Attribute count for ${s}:`, Object.keys(n["attributes"]).length);
          } else {
            console.log(`No matching node data found for ${s} in BOM`);
            
            // Try to find node data by searching through all BOM nodes with different matching strategies
            if (bom_obj.hasOwnProperty('nodes')) {
              var node_keys = Object.keys(bom_obj['nodes']);
              console.log(`Searching through ${node_keys.length} nodes for alternate match`);
              
              for (let i = 0; i < node_keys.length; i++) {
                var node_key = node_keys[i];
                var node_data = bom_obj['nodes'][node_key];
                
                // Check various possible name formats
                var possible_names = [
                  node_key,
                  node_key.split('#').pop(),
                  node_data.name,
                  node_data.name ? node_data.name.split('#').pop() : null,
                  node_data.uri,
                  node_data.uri ? node_data.uri.split('#').pop() : null
                ].filter(n => n); // Remove null values
                
                if (possible_names.includes(s)) {
                  console.log(`Found node data via alternate lookup for ${s} using key ${node_key}`);
                  
                  if (node_data.depth !== undefined) {
                    n["depth"] = node_data.depth;
                  }
                  
                  // Extract properties
                  let properties = {};
                  if (node_data.properties && typeof node_data.properties === 'object') {
                    properties = node_data.properties;
                  } else {
                    // Copy root-level properties
                    Object.keys(node_data).forEach(key => {
                      if (!['name', 'depth', 'dependencies', 'richDependencies', 'uri'].includes(key)) {
                        properties[key] = node_data[key];
                      }
                    });
                  }
                  
                  // Add filtered properties
                  Object.keys(properties).forEach(prop => {
                    const edgeProps = ['StartNode', 'EndNode', 'DirectConnection', 'Piping', 'Signal', 
                                      'ConnectToProcess', 'Edge', 'connection', 'depends on', 
                                      'source', 'target', 'weight', 'label'];
                    const isEdgeType = edgeProps.includes(prop) || 
                                      prop.includes('Connection') || 
                                      prop === 'Piping' || 
                                      prop === 'Signal' ||
                                      prop === 'ConnectToProcess';
                    
                    if (!isEdgeType) {
                      n["attributes"][prop] = properties[prop];
                    }
                  });
                  
                  console.log(`Added ${Object.keys(n["attributes"]).length} attributes via alternate lookup`);
                  break;
                }
              }
            }
          }
          
          // Double-check attributes are still there before pushing
          console.log(`Before push - Node ${s} attributes:`, n["attributes"], 'count:', Object.keys(n["attributes"]).length);
          nodes.push(n);
        });

        // After processing nodes and regular edges, add lateral connections
        if (bom_obj.hasOwnProperty('lateral_connections') && Array.isArray(bom_obj.lateral_connections)) {
          console.log('Found lateral_connections:', bom_obj.lateral_connections.length);
          
          bom_obj.lateral_connections.forEach(conn => {
            // Ensure both nodes exist in our nodes_set
            if (conn.source && conn.target) {
              const sourceName = conn.source.includes('#') ? conn.source.split('#').pop() : conn.source;
              const targetName = conn.target.includes('#') ? conn.target.split('#').pop() : conn.target;
              
              // Add nodes if they don't exist
              if (!nodes_set.has(sourceName)) {
                nodes_set.add(sourceName);
                // Add a basic node for this lateral connection node
                nodes.push({
                  name: sourceName,
                  id: sourceName,
                  type: "vertex",
                  adjCount: 0,
                  depth: conn.properties?.sourceDepth || 999, // Use high depth for lateral nodes
                  attributes: {}
                });
              }
              
              if (!nodes_set.has(targetName)) {
                nodes_set.add(targetName);
                // Add a basic node for this lateral connection node
                nodes.push({
                  name: targetName,
                  id: targetName,
                  type: "vertex",
                  adjCount: 0,
                  depth: conn.properties?.targetDepth || 999, // Use high depth for lateral nodes
                  attributes: {}
                });
              }
              
              // Create lateral edge
              const lateralEdge = {
                source: sourceName,
                target: targetName,
                weight: 0.8,
                label: conn.properties?.predicate || "lateral connection",
                isLateralConnection: true,
                properties: conn.properties || {}
              };
              
              // Check if this edge doesn't already exist
              const edgeExists = edges.some(e => 
                (e.source === sourceName && e.target === targetName) ||
                (e.source === targetName && e.target === sourceName)
              );
              
              if (!edgeExists) {
                edges.push(lateralEdge);
                console.log('Added lateral connection:', sourceName, '->', targetName);
              }
            }
          });
        }

        console.log('=== BOM Parsing Summary ===');
        console.log('Total nodes:', nodes.length);
        console.log('Total edges:', edges.length);
        const lateralEdges = edges.filter(e => e.isLateralConnection);
        console.log('Lateral connections:', lateralEdges.length);
        
        // Debug edge connectivity
        console.log('=== Edge Connectivity Debug ===');
        const nodeIds = new Set(nodes.map(n => n.id));
        console.log('Node IDs:', Array.from(nodeIds).slice(0, 5), '... (first 5)');
        
        edges.forEach((edge, i) => {
          if (i < 3) { // Show first 3 edges
            console.log(`Edge ${i}:`, {
              source: edge.source,
              target: edge.target,
              sourceExists: nodeIds.has(edge.source),
              targetExists: nodeIds.has(edge.target),
              isLateral: edge.isLateralConnection || false
            });
          }
        });
        
        const missingSources = edges.filter(e => !nodeIds.has(e.source));
        const missingTargets = edges.filter(e => !nodeIds.has(e.target));
        console.log('Edges with missing source nodes:', missingSources.length);
        console.log('Edges with missing target nodes:', missingTargets.length);
        
        if (missingSources.length > 0) {
          console.log('Example missing source:', missingSources[0].source);
        }
        if (missingTargets.length > 0) {
          console.log('Example missing target:', missingTargets[0].target);
        }

        console.log('=== Final node depth summary ===');
        nodes.forEach(node => {
          console.log('Node:', node.name, '-> depth:', node.depth);
        });

        console.log('Final processing results:');
        console.log('- Nodes count:', nodes.length);
        console.log('- Edges count:', edges.length);
        console.log('- Node names:', nodes.map(n => n.name));
        console.log('- Edge connections:', edges.map(e => `${e.source} -> ${e.target} (${e.isLateralConnection ? 'lateral' : 'direct'})`));

        // Always try to create visualization, even with just nodes
        if (nodes.length > 0) {
          console.log('Starting visualization with', nodes.length, 'nodes and', edges.length, 'edges');
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = '';

          // For large datasets, automatically disable link labels and node details by default
          const LARGE_DATASET_THRESHOLD = 100;
          const isLargeDataset = nodes.length > LARGE_DATASET_THRESHOLD;
          
          // Store original toggle states before potentially modifying them
          const linkToggle = document.getElementById('toggle-link-labels');
          const nodeToggle = document.getElementById('toggle-node-attributes');
          
          console.log(`Dataset size: ${nodes.length} nodes (large dataset threshold: ${LARGE_DATASET_THRESHOLD})`);
          console.log('Original toggle states - Link:', linkToggle ? linkToggle.checked : 'not found', 'Node:', nodeToggle ? nodeToggle.checked : 'not found');
          
          if (isLargeDataset) {
            console.log(`Large dataset detected (${nodes.length} nodes) - disabling labels by default for performance`);
            
            // Uncheck the toggle buttons for large datasets but DON'T prune the data
            if (linkToggle && linkToggle.checked) {
              linkToggle.checked = false;
              console.log('Unchecked link toggle for large dataset');
            }
            if (nodeToggle && nodeToggle.checked) {
              nodeToggle.checked = false; 
              console.log('Unchecked node toggle for large dataset');
            }
          }

          // Clear any existing content including test circle
          d3.select("#graph-svg").selectAll("*").remove();

          // Set up the SVG dimensions
          const svg = d3.select("#graph-svg");
          const width = 800;
          const height = 600;

          svg.attr("viewBox", `0 0 ${width} ${height}`);

          const g = svg.append("g").attr("id", "graph-container");

          console.log("Setting up visualization...");

          // Add arrow marker if we have edges
          if (edges.length > 0) {
            svg.append('defs')
              .append('marker')
              .attr("id", "Triangle")
              .attr("refX", 12)
              .attr("refY", 6)
              .attr("markerUnits", 'userSpaceOnUse')
              .attr("markerWidth", 12)
              .attr("markerHeight", 18)
              .attr("orient", 'auto')
              .append('path')
              .attr("d", 'M 0 0 12 6 0 12 3 6')
              .style("fill", "#666666");
            
            // Add a different marker for lateral connections
            svg.select('defs')
              .append('marker')
              .attr("id", "TriangleLateral")
              .attr("refX", 12)
              .attr("refY", 6)
              .attr("markerUnits", 'userSpaceOnUse')
              .attr("markerWidth", 12)
              .attr("markerHeight", 18)
              .attr("orient", 'auto')
              .append('path')
              .attr("d", 'M 0 0 12 6 0 12 3 6')
              .style("fill", "#999999");
          }

          // Create a copy of nodes and edges for D3
          const graphNodes = nodes.map(d => ({ ...d }));
          const allGraphEdges = edges.map(d => ({
            source: d.source,
            target: d.target,
            weight: d.weight || 1,
            label: d.label || "connects",
            displayLabel: d.displayLabel || "",
            tooltipText: d.tooltipText || "",
            properties: d.properties || {},
            type: d.type || "connection",
            isLateralConnection: d.isLateralConnection || false,
            itemTag: d.itemTag || "",
            nominalDiameter: d.nominalDiameter || "",
            flowDir: d.flowDir || "",
            drawingNumber: d.drawingNumber || ""
          }));

          // Deduplicate edges - only keep one edge per unique source-target pair
          const edgeMap = new Map();
          allGraphEdges.forEach(edge => {
            // Simple key: just source-target, no bidirectional deduplication
            const key = `${edge.source}-${edge.target}`;
            
            // Only add if this exact source->target doesn't exist yet
            if (!edgeMap.has(key)) {
              edgeMap.set(key, edge);
            }
          });
          
          // Use the deduplicated edges
          const graphEdges = Array.from(edgeMap.values());

          console.log("Graph nodes for D3:", graphNodes);
          console.log("Graph edges for D3 (deduplicated):", graphEdges);
          console.log("Original edges count:", allGraphEdges.length, "Deduplicated count:", graphEdges.length);
          const lateralCount = graphEdges.filter(e => e.isLateralConnection).length;
          console.log("Lateral edges count:", lateralCount);
          
          // Debug: Check edge source/target types
          if (graphEdges.length > 0) {
            console.log("First edge source type:", typeof graphEdges[0].source, "value:", graphEdges[0].source);
            console.log("First edge target type:", typeof graphEdges[0].target, "value:", graphEdges[0].target);
          }
          
          // Debug: Log edge source-target pairs to check for duplicates
          const edgePairs = graphEdges.map(e => `${e.source} ‚Üí ${e.target} (${e.isLateralConnection ? 'LATERAL' : e.displayLabel || e.label})`);
          console.log("Final edge pairs:", edgePairs);





          // Create the simulation with WebGPU detection
          let simulation;
          let useWebGPU = false;
          let webgpuDevice = null;
          
          // Detect WebGPU support
          async function detectWebGPU() {
            console.log('üîç Detecting WebGPU support...');
            
            if (!navigator.gpu) {
              console.log('‚ùå WebGPU not supported: navigator.gpu not available');
              return false;
            }
            
            console.log('‚úÖ navigator.gpu available, requesting adapter...');
            
            try {
              // Try high-performance GPU first 
              console.log('üéØ Requesting high-performance GPU adapter...');
              let adapter = await navigator.gpu.requestAdapter({
                powerPreference: 'high-performance',
                forceFallbackAdapter: false
              });
              
              // If that doesn't work, try default adapter
              if (!adapter) {
                console.log('‚ùå High-performance adapter failed, trying default...');
                adapter = await navigator.gpu.requestAdapter({
                  powerPreference: 'default'
                });
              }
              
              // Last resort: try low-power adapter
              if (!adapter) {
                console.log('‚ùå Default adapter failed, trying low-power...');
                adapter = await navigator.gpu.requestAdapter({
                  powerPreference: 'low-power'
                });
              }
              
              if (!adapter) {
                console.log('‚ùå WebGPU adapter request failed');
                return false;
              }
              
              console.log('‚úÖ WebGPU adapter obtained:', {
                features: Array.from(adapter.features),
                limits: adapter.limits,
                info: adapter.info
              });
              
              // Log detailed GPU information to identify which GPU we're using
              if (adapter.info) {
                console.log('üéÆ GPU Details:', {
                  vendor: adapter.info.vendor,
                  architecture: adapter.info.architecture,
                  device: adapter.info.device,
                  description: adapter.info.description
                });
                
                // Check if we got the desired NVIDIA or AMD GPU
                const isNVIDIA = adapter.info.vendor?.toLowerCase().includes('nvidia') || 
                               adapter.info.description?.toLowerCase().includes('nvidia');
                const isAMD = adapter.info.vendor?.toLowerCase().includes('amd') || 
                              adapter.info.description?.toLowerCase().includes('amd');
                const isHighPerf = adapter.info.description?.toLowerCase().includes('rtx') ||
                                 adapter.info.description?.toLowerCase().includes('gtx') || 
                                 adapter.info.description?.toLowerCase().includes('ryzen') ||
                                 adapter.info.description?.toLowerCase().includes('radeon');
                
                if (isNVIDIA) {
                  console.log('üöÄ NVIDIA GPU detected!');
                } else if (isAMD) {
                  console.log('üöÄ AMD GPU detected!');
                } else if (isHighPerf) {
                  console.log('‚ö° High-performance GPU detected!');
                } else {
                  console.log('‚ÑπÔ∏è Using integrated/alternative GPU. For best performance, ensure Chrome uses your NVIDIA/AMD GPU.');
                  console.log('üí°FOR EXAMPLE, TO FORCE NVIDIA GPU IN CHROME:');
                  console.log('   Method 1 - Windows Graphics Settings:');
                  console.log('   ‚Ä¢ Windows Settings ‚Üí System ‚Üí Display ‚Üí Graphics Settings');
                  console.log('   ‚Ä¢ Browse and select Chrome.exe');
                  console.log('   ‚Ä¢ Set to "High Performance" (NVIDIA)');
                  console.log('   Method 2 - NVIDIA Control Panel:');
                  console.log('   ‚Ä¢ Right-click desktop ‚Üí NVIDIA Control Panel');
                  console.log('   ‚Ä¢ 3D Settings ‚Üí Manage 3D Settings ‚Üí Program Settings');
                  console.log('   ‚Ä¢ Add Chrome ‚Üí Set to "High-performance NVIDIA processor"');
                  console.log('   Method 3 - Chrome Flags:');
                  console.log('   ‚Ä¢ Go to chrome://flags/#use-angle');
                  console.log('   ‚Ä¢ Set "Choose ANGLE graphics backend" to "D3D11on12"');
                  console.log('   ‚Ä¢ Restart Chrome');
                }
              }
              
              const device = await adapter.requestDevice();
              console.log('‚úÖ WebGPU device obtained:', device);
              
              webgpuDevice = device;
              return true;
              
            } catch (error) {
              console.log('‚ùå WebGPU detection failed:', error);
              return false;
            }
          }
          
          // WebGPU-accelerated force calculation compute shader
          const webgpuForceShader = `
            struct Node {
              x: f32,
              y: f32,
              vx: f32,
              vy: f32,
            };
            
            struct NodeBuffer {
              nodes: array<Node>,
            };
            
            @group(0) @binding(0) var<storage, read_write> nodeBuffer: NodeBuffer;
            @group(0) @binding(1) var<uniform> params: vec4<f32>; // [nodeCount, strength, centerX, centerY]
            
            @compute @workgroup_size(64)
            fn computeForces(@builtin(global_invocation_id) global_id: vec3<u32>) {
              let index = global_id.x;
              let nodeCount = u32(params.x);
              
              if (index >= nodeCount) {
                return;
              }
              
              let strength = params.y;
              let centerX = params.z;
              let centerY = params.w;
              
              var node = nodeBuffer.nodes[index];
              var fx: f32 = 0.0;
              var fy: f32 = 0.0;
              
              // Many-body repulsion force (similar to D3's forceManyBody)
              for (var i: u32 = 0u; i < nodeCount; i = i + 1u) {
                if (i != index) {
                  let other = nodeBuffer.nodes[i];
                  let dx = node.x - other.x;
                  let dy = node.y - other.y;
                  let distSq = dx * dx + dy * dy + 0.01; // Small epsilon to prevent division by zero
                  
                  // Only apply force if nodes are close enough (performance optimization)
                  if (distSq < 10000.0) { // Within ~100 pixel radius
                    let dist = sqrt(distSq);
                    let force = strength / distSq;
                    fx = fx + (dx / dist) * force;
                    fy = fy + (dy / dist) * force;
                  }
                }
              }
              
              // Center force (similar to D3's forceCenter)
              let centerForce = 0.03;
              fx = fx + (centerX - node.x) * centerForce;
              fy = fy + (centerY - node.y) * centerForce;
              
              // Update velocity with proper damping (similar to D3's velocity decay)
              let damping = 0.4; // More aggressive damping to match D3 behavior
              node.vx = (node.vx + fx) * damping;
              node.vy = (node.vy + fy) * damping;
              
              // Update position
              node.x = node.x + node.vx;
              node.y = node.y + node.vy;
              
              nodeBuffer.nodes[index] = node;
            }
          `;
          
          // WebGPU force calculation manager
          class WebGPUForceSimulation {
            constructor(device, nodes, width, height) {
              this.device = device;
              this.nodes = nodes;
              this.width = width;
              this.height = height;
              this.pipeline = null;
              this.nodeBuffer = null;
              this.paramsBuffer = null;
              this.bindGroup = null;
              this.isInitialized = false;
            }
            
            async initialize() {
              try {
                // Create compute shader module
                const shaderModule = this.device.createShaderModule({
                  code: webgpuForceShader
                });
                
                // Create bind group layout explicitly
                const bindGroupLayout = this.device.createBindGroupLayout({
                  entries: [
                    {
                      binding: 0,
                      visibility: GPUShaderStage.COMPUTE,
                      buffer: {
                        type: 'storage'
                      }
                    },
                    {
                      binding: 1,
                      visibility: GPUShaderStage.COMPUTE,
                      buffer: {
                        type: 'uniform'
                      }
                    }
                  ]
                });
                
                // Create pipeline layout
                const pipelineLayout = this.device.createPipelineLayout({
                  bindGroupLayouts: [bindGroupLayout]
                });
                
                // Create compute pipeline with explicit layout
                this.pipeline = this.device.createComputePipeline({
                  layout: pipelineLayout,
                  compute: {
                    module: shaderModule,
                    entryPoint: 'computeForces'
                  }
                });
                
                // Create node buffer (x, y, vx, vy for each node)
                // Ensure nodes have random initial positions if not set
                const nodeData = new Float32Array(this.nodes.length * 4);
                this.nodes.forEach((node, i) => {
                  // Initialize with random positions if not already set
                  if (node.x === undefined || node.x === null) {
                    node.x = Math.random() * this.width;
                  }
                  if (node.y === undefined || node.y === null) {
                    node.y = Math.random() * this.height;
                  }
                  
                  nodeData[i * 4] = node.x;
                  nodeData[i * 4 + 1] = node.y;
                  nodeData[i * 4 + 2] = node.vx || 0;
                  nodeData[i * 4 + 3] = node.vy || 0;
                });
                
                this.nodeBuffer = this.device.createBuffer({
                  size: nodeData.byteLength,
                  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
                  mappedAtCreation: true
                });
                new Float32Array(this.nodeBuffer.getMappedRange()).set(nodeData);
                this.nodeBuffer.unmap();
                
                // Create parameters buffer [nodeCount, strength, centerX, centerY]
                // Use force strength similar to D3's default many-body force
                const paramsData = new Float32Array([
                  this.nodes.length,
                  -30.0, // Reduced force strength to match D3 behavior better
                  this.width / 2,
                  this.height / 2
                ]);
                
                this.paramsBuffer = this.device.createBuffer({
                  size: paramsData.byteLength,
                  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                  mappedAtCreation: true
                });
                new Float32Array(this.paramsBuffer.getMappedRange()).set(paramsData);
                this.paramsBuffer.unmap();
                
                // Create bind group using the explicit layout
                this.bindGroup = this.device.createBindGroup({
                  layout: bindGroupLayout,
                  entries: [
                    {
                      binding: 0,
                      resource: {
                        buffer: this.nodeBuffer
                      }
                    },
                    {
                      binding: 1,
                      resource: {
                        buffer: this.paramsBuffer
                      }
                    }
                  ]
                });
                
                this.isInitialized = true;
                console.log('‚úÖ WebGPU force simulation initialized');
                return true;
                
              } catch (error) {
                console.error('‚ùå WebGPU force simulation initialization failed:', error);
                return false;
              }
            }
            
            async computeStep() {
              if (!this.isInitialized) return false;
              
              try {
                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                
                passEncoder.setPipeline(this.pipeline);
                passEncoder.setBindGroup(0, this.bindGroup);
                
                const workgroupCount = Math.ceil(this.nodes.length / 64);
                passEncoder.dispatchWorkgroups(workgroupCount);
                passEncoder.end();
                
                // Copy results back to CPU
                const stagingBuffer = this.device.createBuffer({
                  size: this.nodes.length * 4 * 4,
                  usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                });
                
                commandEncoder.copyBufferToBuffer(
                  this.nodeBuffer, 0,
                  stagingBuffer, 0,
                  this.nodes.length * 4 * 4
                );
                
                this.device.queue.submit([commandEncoder.finish()]);
                
                // Read back the results
                await stagingBuffer.mapAsync(GPUMapMode.READ);
                const resultData = new Float32Array(stagingBuffer.getMappedRange());
                
                // Update D3 nodes with GPU-calculated positions
                this.nodes.forEach((node, i) => {
                  node.x = resultData[i * 4];
                  node.y = resultData[i * 4 + 1];
                  node.vx = resultData[i * 4 + 2];
                  node.vy = resultData[i * 4 + 3];
                });
                
                stagingBuffer.unmap();
                stagingBuffer.destroy();
                
                return true;
                
              } catch (error) {
                console.error('‚ùå WebGPU compute step failed:', error);
                return false;
              }
            }
            
            destroy() {
              if (this.nodeBuffer) this.nodeBuffer.destroy();
              if (this.paramsBuffer) this.paramsBuffer.destroy();
            }
          }
          
          // Initialize WebGPU detection synchronously
          console.log('üöÄ Starting WebGPU detection for enhanced performance');
          
          // Run WebGPU detection immediately and update UI when complete
          detectWebGPU().then(gpuSupported => {
            useWebGPU = gpuSupported;
            console.log(useWebGPU ? 
              'üéÆ WebGPU acceleration detected and enabled!' : 
              'üíª WebGPU not available, using CPU mode');
            
            // Update performance indicator immediately when detection completes
            updatePerformanceIndicator();
            
          }).catch(error => {
            console.log('‚ö†Ô∏è WebGPU detection failed, using CPU mode:', error);
            useWebGPU = false;
            webgpuDevice = null;
            updatePerformanceIndicator();
          });
          
          // Debug D3 availability
          console.log('D3 version:', d3.version);
          console.log('d3.forceSimulation available:', typeof d3.forceSimulation);
          console.log('d3.forceManyBody available:', typeof d3.forceManyBody);
          console.log('d3.forceCenter available:', typeof d3.forceCenter);
          console.log('d3.forceCollide available:', typeof d3.forceCollide);
          console.log('d3.forceLink available:', typeof d3.forceLink);
          
          // Test basic simulation creation
          console.log('Testing basic simulation creation...');
          try {
            const testSim = d3.forceSimulation();
            console.log('Basic simulation created successfully:', typeof testSim);
            console.log('Basic simulation has .force method:', typeof testSim.force);
            if (typeof testSim.force === 'function') {
              testSim.stop(); // Stop the test simulation
              console.log('Basic simulation test passed');
            } else {
              console.error('Basic simulation test failed - no .force method');
            }
          } catch (e) {
            console.error('Basic simulation test failed with error:', e);
          }
          
          // Ensure all nodes have initial positions before simulation
          console.log('Initializing node positions...');
          graphNodes.forEach(node => {
            if (node.x === undefined || node.x === null || node.x === 0) {
              node.x = Math.random() * width;
            }
            if (node.y === undefined || node.y === null || node.y === 0) {
              node.y = Math.random() * height;
            }
            console.log(`Node ${node.id}: x=${node.x}, y=${node.y}`);
          });

          // Create simulation with the node data
          try {
            console.log('Creating forceSimulation with', graphNodes.length, 'nodes');
            simulation = d3.forceSimulation(graphNodes);
            console.log('Simulation created, type:', typeof simulation);
            console.log('Simulation object:', simulation);
            console.log('Simulation.force method:', typeof simulation.force);
            
            // Check if simulation has the expected methods
            console.log('Simulation methods available:', Object.getOwnPropertyNames(simulation).filter(name => typeof simulation[name] === 'function'));
            
            if (typeof simulation.force !== 'function') {
              console.error('Simulation does not have .force method!');
              console.error('Simulation prototype:', Object.getPrototypeOf(simulation));
              console.error('Constructor name:', simulation.constructor.name);
              throw new Error('d3.forceSimulation did not return a valid simulation object');
            }
            
            console.log('Simulation created, adding forces...');
            
            simulation
              .force("charge", d3.forceManyBody().strength(-300))
              .force("center", d3.forceCenter(width / 2, height / 2))
              .force("collision", d3.forceCollide().radius(20));

            // Add link force only if we have edges
            if (graphEdges.length > 0) {
              console.log('Adding link force for', graphEdges.length, 'edges');
              simulation.force("link", d3.forceLink(graphEdges)
                .id(d => d.id)
                .distance(d => d.isLateralConnection ? 150 : 100));
            }
            
            console.log('Simulation created successfully, setting up visualization');
            
            console.log('üîß Checking WebGPU device availability...');
            console.log('webgpuDevice:', webgpuDevice);
            console.log('useWebGPU flag:', useWebGPU);
            
            // Initialize WebGPU force simulation if available
            let webgpuSim = null;
            
            // Wait for WebGPU detection to complete before initializing
            setTimeout(async () => {
              console.log('‚è±Ô∏è Delayed WebGPU initialization check...');
              console.log('webgpuDevice after delay:', webgpuDevice);
              console.log('useWebGPU after delay:', useWebGPU);
              
              if (useWebGPU && webgpuDevice && graphNodes.length > 50) { // Only use WebGPU for larger graphs
                console.log('üöÄ Initializing WebGPU-accelerated force simulation...');
                webgpuSim = new WebGPUForceSimulation(webgpuDevice, graphNodes, width, height);
                
                const initialized = await webgpuSim.initialize();
                if (initialized) {
                  console.log('‚úÖ WebGPU force simulation ready for GPU-accelerated physics');
                  
                  // For now, let's keep D3 forces active and just log WebGPU availability
                  // Instead of completely replacing D3, we'll use hybrid approach
                  console.log('üéÆ WebGPU available but keeping D3 forces for stability');
                  
                  // Optional: You can enable WebGPU replacement by uncommenting these lines:
                  /*
                  simulation
                    .force("charge", null)  // Disable CPU many-body force
                    .force("center", null)  // Disable CPU center force
                    .force("collision", null); // Disable CPU collision force
                  
                  // Replace D3's tick calculations with WebGPU
                  simulation.on('tick', async () => {
                    if (webgpuSim && webgpuSim.isInitialized) {
                      await webgpuSim.computeStep();
                    }
                  });
                  */
                  
                  updatePerformanceIndicator();
                } else {
                  console.log('‚ùå WebGPU force simulation initialization failed, using D3 forces');
                }
              } else {
                console.log('üíª Using D3-only force simulation (WebGPU disabled or small graph)');
              }
            }, 1000); // Wait 1 second for WebGPU detection to complete
            
          } catch (error) {
            console.error('Error creating D3 simulation:', error);
            console.error('Error details:', error.message);
            throw error;
          }
          
          // Add performance indicator to the UI
          const perfIndicator = document.createElement('div');
          perfIndicator.id = 'perf-indicator';
          perfIndicator.style.cssText = `
            position: absolute;
            top: 55px;
            right: 10px;
            background: ${useWebGPU ? '#28a745' : '#6c757d'};
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            z-index: 1000;
            opacity: 0.8;
          `;
          perfIndicator.textContent = useWebGPU ? 
            `‚ö° WebGPU (${graphNodes.length}N, ${graphEdges.length}E)` : 
            `üñ•Ô∏è CPU (${graphNodes.length}N, ${graphEdges.length}E)`;
          
          const vizWrapper = document.getElementById('viz_wrapper');
          if (vizWrapper) {
            vizWrapper.style.position = 'relative';
            vizWrapper.appendChild(perfIndicator);
            
            // Auto-hide indicator after 8 seconds (give WebGPU time to initialize)
            setTimeout(() => {
              perfIndicator.style.opacity = '0.3';
            }, 8000);
          }
          
          // Function to update performance indicator
          function updatePerformanceIndicator() {
            if (perfIndicator) {
              perfIndicator.style.background = useWebGPU ? '#28a745' : '#6c757d';
              perfIndicator.textContent = useWebGPU ? 
                `‚ö° WebGPU (${graphNodes.length}N, ${graphEdges.length}E)` : 
                `üñ•Ô∏è CPU (${graphNodes.length}N, ${graphEdges.length}E)`;
            }
          }
          
          // Update indicator when WebGPU status changes
          setTimeout(() => {
            updatePerformanceIndicator();
          }, 100); // Small delay to ensure WebGPU detection completes
          
          // Now set up the rest of the visualization
          setupVisualization();
          
          function setupVisualization() {
          // Create links only if we have edges
          let link = null;
          let linkLabels = null;
          if (graphEdges.length > 0) {
            link = g.append("g")
              .attr("class", "links")
              .selectAll("line")
              .data(graphEdges)
              .enter().append("line")
              .attr("class", "link")
              .style("stroke", d => d.isLateralConnection ? "#ff9999" : "#666666")
              .style("stroke-width", d => d.isLateralConnection ? 1.5 : 2)
              .style("stroke-dasharray", d => d.isLateralConnection ? "5,5" : "none")
              .style("opacity", d => d.isLateralConnection ? 0.6 : 1)
              .attr("marker-end", d => d.isLateralConnection ? "url(#TriangleLateral)" : "url(#Triangle)");

            // Add tooltips to edges showing rich dependency information
            link.append("title")
              .text(d => {
                // Add lateral indicator
                const lateralPrefix = d.isLateralConnection ? "[LATERAL] " : "";
                // Use short displayLabel for cleaner tooltips
                if (d.displayLabel && d.displayLabel !== "") {
                  return lateralPrefix + d.displayLabel;
                } else if (d.edgeLabel && d.edgeLabel !== "") {
                  return lateralPrefix + d.edgeLabel;
                } else if (d.label) {
                  return lateralPrefix + d.label;
                } else {
                  // Fallback to simple connection label
                  return `${lateralPrefix}${d.source} ‚Üí ${d.target}`;
                }
              });

            // Add labels to edges with proper angle alignment - optimized
            linkLabels = g.append("g")
              .attr("class", "link-labels")
              .style("will-change", "transform") // GPU hint for label container
              .selectAll("text")
              .data(graphEdges.filter(d => { // Pre-filter empty labels to reduce DOM elements
                const hasLabel = d.isLateralConnection || 
                  (d.displayLabel && d.displayLabel !== "") ||
                  (d.label && d.label !== "depends on" && d.label !== "connects") ||
                  (d.type && d.type !== "connection");
                return hasLabel;
              }))
              .enter().append("text")
              .attr("class", "link-label")
              .style("font-size", "8px")
              .style("fill", d => d.isLateralConnection ? "#ff6666" : "#4a5568")
              .style("text-anchor", "middle")
              .style("pointer-events", "none")
              .style("text-shadow", "none")
              .style("font-style", d => d.isLateralConnection ? "italic" : "normal")
              .text(d => {
                // Pre-computed clean labels
                if (d.isLateralConnection) {
                  return "lateral";
                } else if (d.displayLabel && d.displayLabel !== "") {
                  return d.displayLabel.replace(/[‚Üê‚Üí‚Üî]/g, '').trim();
                } else if (d.label && d.label !== "depends on" && d.label !== "connects") {
                  return d.label.replace(/[‚Üê‚Üí‚Üî]/g, '').trim();
                } else if (d.type && d.type !== "connection") {
                  return d.type;
                } else {
                  return "";
                }
              });
          }

          // Performance: create node groups with will-change hint
          const nodeContainer = g.append("g")
            .attr("class", "nodes")
            .style("will-change", "transform"); // GPU hint for container
            
          const node = nodeContainer
            .selectAll("g")
            .data(graphNodes)
            .enter().append("g")
            .attr("class", "node")
            .style("will-change", "transform") // GPU hint per node
            .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended));

          // Add circles to nodes
          node.append("circle")
            .attr("r", d => d.depth === 0 ? 8 : 6) // Larger circle for starting node
            .style("fill", d => {
              if (d.depth === 0) return "#ff6b35"; // Bright orange for starting node
              return getNodeColor(d.name, d.depth);
            })
            .style("stroke", d => d.depth === 0 ? "#fff" : "none") // White stroke for starting node
            .style("stroke-width", d => d.depth === 0 ? 2 : 0); // Thicker stroke for starting node

          // Add background rectangles for starting node labels
          node.filter(d => d.depth === 0)
            .append("rect")
            .attr("x", 6) // Position slightly before text
            .attr("y", d => {
              // Calculate height based on number of attribute lines
              const attrCount = d.attributes ? Math.min(Object.keys(d.attributes).length, 3) : 0;
              const totalLines = 1 + attrCount; // Primary name + attribute lines
              const lineHeight = 11; // Reduced line height for more compact layout
              const totalHeight = totalLines * lineHeight;
              return -totalHeight/2; // Center vertically with no extra padding
            })
            .attr("width", d => {
              // Calculate width based on primary label (which is larger and bold for starting nodes)
              const primaryFontSize = 12; // 12px font for starting node
              const primaryCharWidth = 8; // More accurate for 12px bold font
              const primaryWidth = d.name.length * primaryCharWidth;
              
              // Calculate secondary attribute widths
              const attrCount = d.attributes ? Math.min(Object.keys(d.attributes).length, 3) : 0;
              let maxSecondaryWidth = 0;
              
              if (attrCount > 0) {
                // Estimate width of attribute lines (11px font)
                const secondaryCharWidth = 6.5; // For 11px font
                const avgAttrLineLength = 20; // Reasonable estimate for "Type: Product" etc.
                maxSecondaryWidth = avgAttrLineLength * secondaryCharWidth;
              }
              
              // Use the wider of primary or secondary content, plus padding
              const contentWidth = Math.max(primaryWidth, maxSecondaryWidth);
              return contentWidth + 8; // Adequate horizontal padding
            })
            .attr("height", d => {
              const attrCount = d.attributes ? Math.min(Object.keys(d.attributes).length, 3) : 0;
              const totalLines = 1 + attrCount;
              const lineHeight = 11; // Reduced line height
              return totalLines * lineHeight; // No extra vertical padding
            })
            .attr("rx", 2) // Even smaller rounded corners
            .attr("ry", 2)
            .style("fill", "rgba(255, 107, 53, 0.2)") // Slightly more opaque for better visibility
            .style("stroke", "none"); // Remove border completely

          // Add labels to nodes - multi-line with attributes
          const nodeLabels = node.append("text")
            .style("font-size", d => d.depth === 0 ? "12px" : "10px") // Larger font for starting node
            .style("text-anchor", "start") // Left-align text to start right of circle
            .attr("dx", "8") // Position 8 pixels to the right of circle center
            .attr("dy", "-0.5em") // Start slightly above center for multi-line
            .style("fill", "white")
            .style("text-shadow", "none")
            .style("font-weight", d => d.depth === 0 ? "bold" : "normal"); // Bold for starting node

          nodeLabels.each(function(d) {
            const textElement = d3.select(this);
            const lines = [];
            
            console.log(`\n=== Creating labels for node ${d.name} ===`);
            console.log(`Node object:`, d);
            console.log(`Attributes object:`, d.attributes);
            console.log(`Attribute keys:`, d.attributes ? Object.keys(d.attributes) : 'No attributes');
            
            // First line: Node name (more generous truncation)
            const displayName = d.name.length > 32 ? d.name.substring(0, 32) + '...' : d.name;
            lines.push({ text: displayName, opacity: 1.0 });
            
            // Add up to 3 additional attribute lines
            if (d.attributes && typeof d.attributes === 'object') {
              const attrKeys = Object.keys(d.attributes);
              console.log(`Node ${d.name} has ${attrKeys.length} attribute keys:`, attrKeys);
              
              // Special handling for selfProperties
              let propertiesToShow = {};
              
              // Check if we have selfProperties object
              if (d.attributes.selfProperties && typeof d.attributes.selfProperties === 'object') {
                console.log(`Node ${d.name} has selfProperties:`, d.attributes.selfProperties);
                
                // Merge selfProperties into propertiesToShow
                Object.assign(propertiesToShow, d.attributes.selfProperties);
              }
              
              // Add other properties (excluding visited and selfProperties)
              attrKeys.forEach(key => {
                if (key !== 'visited' && key !== 'selfProperties') {
                  propertiesToShow[key] = d.attributes[key];
                }
              });
              
              console.log(`Properties to show for ${d.name}:`, propertiesToShow);
              
              // Define priority attributes
              const priorityAttributes = ["ItemTag", "DrawingNumber", "DrawingID", "Type", "Subtype", 
                                        "InternalDiameter", "NominalDiameter", "TagPrefix", "TagSequenceNo", 
                                        "Symbol", "FlowDir", "ID", "RunID", "XCoordinate", "YCoordinate",
                                        "MeasuredVariableCode", "LoopFunction", "TagSuffix"];
              

              // Sort keys by priority
              const propKeys = Object.keys(propertiesToShow);
              const sortedKeys = [...propKeys].sort((a, b) => {
                const aIndex = priorityAttributes.indexOf(a);
                const bIndex = priorityAttributes.indexOf(b);
                if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                if (aIndex !== -1) return -1;
                if (bIndex !== -1) return 1;
                return a.localeCompare(b);
              });
              
              console.log(`Sorted property keys for ${d.name}:`, sortedKeys);
              
              // Take up to 3 attributes
              let addedCount = 0;
              for (let i = 0; i < sortedKeys.length && addedCount < 3; i++) {
                const key = sortedKeys[i];
                const value = propertiesToShow[key];
                
                // Skip empty/null/undefined values
                if (value === undefined || value === null || value === '') {
                  console.log(`Skipping empty property ${key}`);
                  continue;
                }
                
                const stringValue = value.toString().trim();
                if (stringValue === '') {
                  console.log(`Skipping empty string property ${key}`);
                  continue;
                }
                
                let displayValue = stringValue;
                console.log(`Processing property ${key} = "${displayValue}" for node ${d.name}`);
                
                // Format based on key type
                if (["ItemTag", "DrawingNumber", "DrawingID", "ID", "RunID"].includes(key)) {
                  // These are usually meaningful IDs - show as-is but truncate if needed
                  if (displayValue.length > 25) {
                    displayValue = displayValue.substring(0, 25) + '...';
                  }
                } else if (["Type", "Subtype"].includes(key)) {
                  // Always show key for Type/Subtype for clarity
                  displayValue = `${key}: ${displayValue}`;
                  if (displayValue.length > 25) {
                    displayValue = displayValue.substring(0, 25) + '...';
                  }
                } else if (["InternalDiameter", "NominalDiameter", "XCoordinate", "YCoordinate"].includes(key)) {
                  // Numeric values - show with key
                  const numValue = parseFloat(displayValue);
                  if (!isNaN(numValue)) {
                    // Format numbers nicely
                    displayValue = `${key}: ${numValue}`;
                  } else {
                    displayValue = `${key}: ${displayValue}`;
                  }
                  if (displayValue.length > 25) {
                    displayValue = displayValue.substring(0, 25) + '...';
                  }
                } else {
                  // For other attributes, include key if value is short or unclear
                  if (displayValue.length < 10 || !displayValue.match(/^[A-Za-z0-9\-_]+$/)) {
                    displayValue = `${key}: ${displayValue}`;
                  }
                  if (displayValue.length > 25) {
                    displayValue = displayValue.substring(0, 25) + '...';
                  }
                }
                
                // Each line gets progressively dimmer
                const opacity = 1.0 - ((addedCount + 1) * 0.2);
                lines.push({ text: displayValue, opacity: opacity });
                addedCount++;
                console.log(`Added line ${addedCount} for ${d.name}: "${displayValue}" with opacity ${opacity}`);
              }
              
              if (addedCount === 0 && sortedKeys.length > 0) {
                console.warn(`No valid properties found to display for node ${d.name} despite having ${sortedKeys.length} property keys`);
              }
            } else {
              console.warn(`No attributes object found for node ${d.name}`);
            }
            
            console.log(`Total lines to display for ${d.name}:`, lines.length, 'Lines:', lines);
            
            // Create tspan elements for each line
            lines.forEach((line, index) => {
              const isStartingNode = d.depth === 0;
              const primaryFontSize = isStartingNode ? "12px" : "10px";
              const secondaryFontSize = isStartingNode ? "11px" : "9px";
              
              const tspan = textElement.append("tspan")
                .attr("x", 8) // Keep consistent x position
                .attr("dy", index === 0 ? "0" : "1.1em") // Line spacing
                .style("font-weight", index === 0 ? "bold" : "normal")
                .style("font-size", index === 0 ? primaryFontSize : secondaryFontSize) // Larger fonts for starting node
                .style("opacity", line.opacity) // Progressive dimming
                .text(line.text);
              
              console.log(`Created tspan ${index} for ${d.name}: "${line.text}" (starting node: ${isStartingNode})`);
            });
            
            console.log(`=== Finished creating ${lines.length} text lines for node ${d.name} ===\n`);
          });

          // Add zoom behavior with initial fit-to-bounds
          const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", function (event) {
              g.attr("transform", event.transform);
              updateLabelVisibility(event.transform.k); // Update labels based on zoom
            });

          svg.call(zoom);

          // Function to update label visibility based on zoom level
          function updateLabelVisibility(scale) {
            const MIN_READABLE_SCALE = 0.8; // 8px text becomes readable at this zoom
            const shouldShowLabels = scale >= MIN_READABLE_SCALE;
            
            // Show/hide all node labels except starting nodes
            d3.selectAll('.node text').style('display', function(d) {
              return (d.depth === 0 || shouldShowLabels) ? null : 'none';
            });
            
            // Show/hide link labels based on both zoom level AND toggle state
            if (linkLabels) {
              const toggleState = window.linkLabelsToggleState !== undefined ? window.linkLabelsToggleState : true;
              linkLabels.style('display', (shouldShowLabels && toggleState) ? null : 'none');
            }
          }

          // Initial zoom to fit all nodes - executed after simulation stabilizes
          function fitToViewport() {
            if (graphNodes.length === 0) return;
            
            // Calculate bounding box of all nodes
            const padding = 50;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            graphNodes.forEach(node => {
              if (node.x < minX) minX = node.x;
              if (node.x > maxX) maxX = node.x;
              if (node.y < minY) minY = node.y;
              if (node.y > maxY) maxY = node.y;
            });
            
            const nodeWidth = maxX - minX + 2 * padding;
            const nodeHeight = maxY - minY + 2 * padding;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            // Calculate scale to fit within viewport
            const scale = Math.min(width / nodeWidth, height / nodeHeight, 1);
            
            // Calculate translation to center
            const translateX = width / 2 - centerX * scale;
            const translateY = height / 2 - centerY * scale;
            
            // Apply the transform
            const transform = d3.zoomIdentity
              .translate(translateX, translateY)
              .scale(scale);
              
            svg.transition()
              .duration(750)
              .call(zoom.transform, transform);
              
            // Update label visibility for the new scale
            updateLabelVisibility(scale);
          }

          // Performance: throttled rendering and cached transforms
          let tickCount = 0;
          // Adjust render throttling based on GPU acceleration and dataset size
          const RENDER_EVERY_N_TICKS = useWebGPU ? 
            (isLargeDataset ? 2 : 1) :  // WebGPU can handle more frequent updates
            (isLargeDataset ? 3 : 1);   // CPU needs more throttling for large datasets
          
          // Create shared update function for better performance
          window.__updatePositions = function() {
            if (link) {
              link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            }

            if (linkLabels) {
              linkLabels
                .attr("x", d => (d.source.x + d.target.x) * 0.5)
                .attr("y", d => (d.source.y + d.target.y) * 0.5)
                .attr("transform", d => {
                  const dx = d.target.x - d.source.x;
                  const dy = d.target.y - d.source.y;
                  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                  const cx = (d.source.x + d.target.x) * 0.5;
                  const cy = (d.source.y + d.target.y) * 0.5;
                  const rot = (angle > 90 || angle < -90) ? angle + 180 : angle;
                  return `rotate(${rot}, ${cx}, ${cy}) translate(0, -5)`;
                });
            }

            // Use CSS transforms for GPU acceleration on nodes
            node.style("transform", d => `translate(${d.x}px, ${d.y}px)`);
          };

          // Performance monitoring variables for WebGPU comparison
          let performanceStartTime = performance.now();
          let lastPerformanceLog = performanceStartTime;
          const PERFORMANCE_LOG_INTERVAL = 100; // Log performance every 100 ticks
          
          // Update positions on tick with throttling and performance monitoring
          simulation.on("tick", function () {
            tickCount++;
            
            // Performance logging for WebGPU vs CPU comparison
            if (tickCount % PERFORMANCE_LOG_INTERVAL === 0) {
              const currentTime = performance.now();
              const ticksPerSecond = PERFORMANCE_LOG_INTERVAL * 1000 / (currentTime - lastPerformanceLog);
              const totalTime = currentTime - performanceStartTime;
              
              console.log(`${useWebGPU ? 'WebGPU' : 'CPU'} Performance - Tick: ${tickCount}, ` +
                         `TPS: ${ticksPerSecond.toFixed(1)}, Total: ${(totalTime/1000).toFixed(1)}s, ` +
                         `Alpha: ${simulation.alpha().toFixed(4)}`);
              
              lastPerformanceLog = currentTime;
            }
            
            if (tickCount % RENDER_EVERY_N_TICKS === 0) {
              scheduleRender(); // Use the RAF scheduler
            }
          });

          // Auto-fit viewport when simulation stabilizes
          simulation.on("end", () => {
            const totalTime = (performance.now() - performanceStartTime) / 1000;
            console.log(`${useWebGPU ? 'WebGPU' : 'CPU'} simulation completed in ${totalTime.toFixed(2)}s ` +
                       `(${tickCount} ticks, ${(tickCount/totalTime).toFixed(1)} TPS avg)`);
            fitToViewport();
          });
          
          // Also fit after a few seconds if simulation doesn't naturally end
          setTimeout(fitToViewport, 3000);

          // Drag functions
          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }

          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }

          // Add click handlers
          node.on("click", function (event, d) {
            console.log("Clicked node:", d.name);
          });

          console.log("Visualization setup complete");

          // Attach toggle handlers for link labels and node secondary labels (tspans)
          (function(){
            const linkToggle = document.getElementById('toggle-link-labels');
            const nodeToggle = document.getElementById('toggle-node-attributes');

            function setLinkLabelsVisibility(show) {
              // Store the toggle state globally so zoom function can respect it
              window.linkLabelsToggleState = show;
              
              // Apply visibility based on both toggle state and current zoom level
              if (linkLabels) {
                const currentZoom = d3.zoomTransform(svg.node()).k;
                const MIN_READABLE_SCALE = 0.8;
                const shouldShowForZoom = currentZoom >= MIN_READABLE_SCALE;
                
                // Show labels only if both toggle is on AND zoom is sufficient
                linkLabels.style('display', (show && shouldShowForZoom) ? null : 'none');
              }
            }

            function setNodeAttributesVisibility(show) {
              // For each node text element, keep the first tspan visible and hide/show others
              d3.selectAll('.node text').each(function() {
                const tspans = d3.select(this).selectAll('tspan').nodes();
                for (let i = 0; i < tspans.length; i++) {
                  const el = d3.select(tspans[i]);
                  if (i === 0) {
                    el.style('display', null); // primary label always visible
                  } else {
                    el.style('display', show ? null : 'none');
                  }
                }
              });
            }

            if (linkToggle) {
              linkToggle.addEventListener('change', function() {
                setLinkLabelsVisibility(this.checked);
              });
            }

            if (nodeToggle) {
              nodeToggle.addEventListener('change', function() {
                setNodeAttributesVisibility(this.checked);
              });
            }

            // Initialize visibility according to default checked state
            if (linkToggle) setLinkLabelsVisibility(linkToggle.checked);
            if (nodeToggle) setNodeAttributesVisibility(nodeToggle.checked);
          })(); // End of async initAndRender function
          
          } // End of setupVisualization function
        } else {
          console.log('No nodes found to visualize');
          const wrapper = document.getElementById('viz_wrapper');
          if (wrapper) wrapper.style.display = 'none';
        }
      } catch (e) {
        console.error('Error parsing BOM JSON:', e);
        console.log('Error details:', e.message);
        console.log('JSON content that failed:', bom_json.substring(0, 500));

        // Show detailed error message in visualization
        // Keep visualization hidden on parse errors
        const wrapper = document.getElementById('viz_wrapper');
        if (wrapper) wrapper.style.display = 'none';
      }
    } else {
      console.log('No BOM data found - element content is empty');
      // Keep hidden when there's no data
      const wrapper = document.getElementById('viz_wrapper');
      if (wrapper) wrapper.style.display = 'none';
    }
  });

  // Local Storage Management for form inputs
  const STORAGE_KEYS = {
    sparqlQuery: 'sparql_console_sparql_query',
    bomQuery: 'sparql_console_bom_query'
  };

  // Load saved values from localStorage
  function loadFromLocalStorage() {
    try {
      // Load SPARQL query (CodeMirror editor)
      const savedSparqlQuery = localStorage.getItem(STORAGE_KEYS.sparqlQuery);
      if (savedSparqlQuery && editor) {
        editor.setValue(savedSparqlQuery);
      }

      // Load BOM query (regular input)
      const savedBomQuery = localStorage.getItem(STORAGE_KEYS.bomQuery);
      const bomQueryInput = document.getElementById('bom_query');
      if (savedBomQuery && bomQueryInput) {
        bomQueryInput.value = savedBomQuery;
      }
    } catch (e) {
      console.warn('Error loading from localStorage:', e);
    }
  }

  // Save values to localStorage
  function saveToLocalStorage() {
    try {
      // Save SPARQL query (CodeMirror editor)
      if (editor) {
        localStorage.setItem(STORAGE_KEYS.sparqlQuery, editor.getValue());
      }

      // Save BOM query (regular input)
      const bomQueryInput = document.getElementById('bom_query');
      if (bomQueryInput) {
        localStorage.setItem(STORAGE_KEYS.bomQuery, bomQueryInput.value);
      }
    } catch (e) {
      console.warn('Error saving to localStorage:', e);
    }
  }

  // Set up event listeners for auto-saving
  function setupAutoSave() {
    // Auto-save CodeMirror editor changes
    if (editor) {
      editor.on('change', function() {
        saveToLocalStorage();
      });
    }

    // Auto-save BOM query input changes
    const bomQueryInput = document.getElementById('bom_query');
    if (bomQueryInput) {
      bomQueryInput.addEventListener('input', saveToLocalStorage);
      bomQueryInput.addEventListener('blur', saveToLocalStorage);
    }
  }

  // Initialize localStorage functionality
  document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for CodeMirror to be fully initialized
    setTimeout(function() {
      loadFromLocalStorage();
      setupAutoSave();
    }, 100);
    
    // Set up results toggle functionality
    setupResultsToggle();
  });

  // Lazy load Prism.js for syntax highlighting
  function loadPrismResources() {
    return new Promise((resolve) => {
      // Check if Prism is already loaded
      if (window.Prism) {
        resolve();
        return;
      }
      
      console.log('Loading Prism.js resources dynamically...');
      
      // Load CSS first
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css';
      document.head.appendChild(link);
      
      // Load main Prism.js
      const script1 = document.createElement('script');
      script1.src = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js';
      script1.onload = () => {
        console.log('Prism.js core loaded');
        
        // Load JSON component
        const script2 = document.createElement('script');
        script2.src = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js';
        script2.onload = () => {
          console.log('Prism.js JSON component loaded successfully');
          resolve();
        };
        script2.onerror = () => {
          console.warn('Failed to load Prism JSON component, continuing without syntax highlighting');
          resolve();
        };
        document.head.appendChild(script2);
      };
      script1.onerror = () => {
        console.warn('Failed to load Prism.js, continuing without syntax highlighting');
        resolve();
      };
      document.head.appendChild(script1);
    });
  }

  // Format and display JSON results with syntax highlighting
  async function formatAndDisplayResults() {
    const resultsData = document.getElementById('results-data');
    const resultsFormatted = document.getElementById('results-formatted');
    
    if (!resultsData || !resultsFormatted) return;
    
    const jsonData = resultsData.textContent.trim();
    if (!jsonData) return;
    
    // Load Prism for syntax highlighting
    await loadPrismResources();
    
    // Create formatted output
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.className = 'language-json';
    codeElement.textContent = jsonData;
    preElement.appendChild(codeElement);
    
    // Clear and append formatted content
    resultsFormatted.innerHTML = '';
    resultsFormatted.appendChild(preElement);
    
    // Apply syntax highlighting if Prism is available
    if (window.Prism) {
      Prism.highlightElement(codeElement);
    }
  }

  // Results toggle functionality
  function setupResultsToggle() {
    const toggleBtn = document.getElementById('toggle-results-btn');
    const resultsContent = document.getElementById('results-content');
    const toggleText = document.getElementById('toggle-results-text');
    const toggleIcon = document.getElementById('toggle-results-icon');
    
    if (!toggleBtn || !resultsContent || !toggleText || !toggleIcon) return;
    
    // Determine initial state based on whether BOM query was executed (graph is shown)
    const vizWrapper = document.getElementById('viz_wrapper');
    const bomQuery = "{{ bom_query }}";
    const hasGraphVisualization = vizWrapper && vizWrapper.style.display !== 'none' && bomQuery.trim() !== '';
    
    // Check if there's an error (error alerts are always visible)
    const hasError = resultsContent && resultsContent.querySelector('.alert-danger');
    
    // Default: hide results if graph is shown, show results if only SPARQL results or if there's an error
    let isVisible = !hasGraphVisualization || hasError;
    let resultsFormatted = false;
    
    // For SPARQL-only queries (no BOM) or errors, format results immediately (skip formatting for errors)
    if ((!hasGraphVisualization || hasError) && !hasError) {
      formatAndDisplayResults();
      resultsFormatted = true;
    }
    
    // Apply initial state
    if (isVisible) {
      resultsContent.style.display = 'block';
      toggleText.textContent = 'Hide';
      toggleIcon.textContent = '‚ñ≤';
    } else {
      resultsContent.style.display = 'none';
      toggleText.textContent = 'Show';
      toggleIcon.textContent = '‚ñº';
    }
    
    // Toggle button click handler
    toggleBtn.addEventListener('click', async function() {
      isVisible = !isVisible;
      
      if (isVisible) {
        // Format results lazily when first shown (only for BOM queries)
        if (!resultsFormatted) {
          await formatAndDisplayResults();
          resultsFormatted = true;
        }
        
        resultsContent.style.display = 'block';
        toggleText.textContent = 'Hide';
        toggleIcon.textContent = '‚ñ≤';
      } else {
        resultsContent.style.display = 'none';
        toggleText.textContent = 'Show';
        toggleIcon.textContent = '‚ñº';
      }
    });
  }
</script>
<script>
  // Patch insertion: Worker + WASM/SIMD infrastructure (guarded)
  if (typeof workerActive === 'undefined') { window.workerActive = false; }
  if (typeof physicsWorker === 'undefined') { window.physicsWorker = null; }
  if (typeof wasmSupported === 'undefined') { window.wasmSupported = false; }
  if (typeof wasmModuleBytes === 'undefined') { window.wasmModuleBytes = null; }
  window.USE_WORKER_THRESHOLD = window.USE_WORKER_THRESHOLD || 120; // enable worker beyond this size
  window.USE_WASM_THRESHOLD = window.USE_WASM_THRESHOLD || 250;   // attempt WASM beyond this size

  if (typeof maybeLoadWasm === 'undefined') {
    async function maybeLoadWasm(totalNodes){
      if (totalNodes < window.USE_WASM_THRESHOLD) return;
      if (!('WebAssembly' in window)) return;
      try {
        const resp = await fetch('/static/wasm/forces_simd.wasm');
        if (!resp.ok) throw new Error('WASM fetch failed');
        wasmModuleBytes = await resp.arrayBuffer();
        wasmSupported = true;
        console.log('[WASM] Module bytes loaded, size:', wasmModuleBytes.byteLength);
        if (physicsWorker) physicsWorker.postMessage({ type: 'wasmModule', bytes: wasmModuleBytes }, [wasmModuleBytes]);
      } catch (e){ console.warn('[WASM] Load failed, fallback JS', e); }
    }
  }

  if (typeof startWorkerPhysics === 'undefined') {
    function startWorkerPhysics(graphNodes, graphEdges, width, height, updatePositions) {
      if (!window.Worker) return false;
      const workerSrc = `(() => {\nlet nodes=[];let links=[];let alpha=1;let alphaDecay=0.02;let velDecay=0.4;let wasm=null;let wasmExports=null;let useWasm=false;\nfunction repulse(){const R=-320;for(let i=0;i<nodes.length;i++){const a=nodes[i];for(let j=i+1;j<nodes.length;j++){const b=nodes[j];let dx=a.x-b.x;let dy=a.y-b.y;let d2=dx*dx+dy*dy+0.01;if(d2>90000) continue;let d=Math.sqrt(d2);let f=R/d2;dx/=d;dy/=d;a.vx+=dx*f;a.vy+=dy*f;b.vx-=dx*f;b.vy-=dy*f;}}}\nfunction linkForce(){for(const L of links){const s=L.s,t=L.t;let dx=t.x-s.x;let dy=t.y-s.y;const d=Math.sqrt(dx*dx+dy*dy)||1;const diff=d-L.d;const k=0.03;const f=diff*k;dx/=d;dy/=d;s.vx+=dx*f;s.vy+=dy*f;t.vx-=dx*f;t.vy-=dy*f;}}\nfunction step(){if(alpha<0.005){postMessage({type:'done'});return;}for(const n of nodes){n.vx*=velDecay;n.vy*=velDecay;}if(useWasm&&wasmExports&&wasmExports.compute){repulse();}else{repulse();}linkForce();for(const n of nodes){if(n.fx!=null){n.x=n.fx;n.vx=0;}else n.x+=n.vx;if(n.fy!=null){n.y=n.fy;n.vy=0;}else n.y+=n.vy;}alpha*=(1-alphaDecay);postMessage({type:'tick',nodes:nodes.map(n=>({id:n.id,x:n.x,y:n.y}))});setTimeout(step,16);}\nfunction init(data){nodes=data.nodes.map(o=>({id:o.id,x:o.x,y:o.y,vx:0,vy:0,fx:o.fx??null,fy:o.fy??null}));const idx=new Map();nodes.forEach((n,i)=>idx.set(n.id,i));links=data.links.map(e=>{const si=idx.get(e.source);const ti=idx.get(e.target);if(si==null||ti==null)return null;return{s:nodes[si],t:nodes[ti],d:e.distance||110};}).filter(Boolean);alpha=1;step();}\nonmessage=async e=>{const m=e.data;if(m.type==='init')init(m.data);else if(m.type==='pin'){const n=nodes.find(n=>n.id===m.id);if(n){n.fx=m.x;n.fy=m.y;alpha=1;}}else if(m.type==='drag'){const n=nodes.find(n=>n.id===m.id);if(n){n.fx=m.x;n.fy=m.y;n.x=m.x;n.y=m.y;}}else if(m.type==='unpin'){const n=nodes.find(n=>n.id===m.id);if(n){n.fx=null;n.fy=null;}}else if(m.type==='restart'){alpha=1;}else if(m.type==='wasm'){try{const r=await WebAssembly.instantiate(m.bytes,{});wasmExports=r.instance.exports;useWasm=!!wasmExports.compute;postMessage({type:'wasmReady',useWasm});}catch(err){postMessage({type:'wasmErr',err:err.message});}}};})();`;
      const blob = new Blob([workerSrc], { type: 'application/javascript' });
      physicsWorker = new Worker(URL.createObjectURL(blob));
      workerActive = true;
      physicsWorker.onmessage = e => {
        const msg = e.data;
        if (msg.type === 'tick') {
          msg.nodes.forEach(p => { const n = graphNodes.find(nn => nn.id === p.id); if (n) { n.x = p.x; n.y = p.y; } });
          updatePositions();
        }
      };
      physicsWorker.postMessage({ type: 'init', data: { nodes: graphNodes.map(n => ({ id: n.id, x: n.x || Math.random()*width, y: n.y || Math.random()*height })), links: graphEdges.map(e => ({ source: e.source, target: e.target, distance: e.isLateralConnection ? 150 : 100 })) } });
      if (graphNodes.length >= window.USE_WASM_THRESHOLD) maybeLoadWasm(graphNodes.length);
      return true;
    }
  }
</script>
{% endblock %}