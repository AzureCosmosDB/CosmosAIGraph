{% extends "layout.html" %}
{% block title %} SPARQL Console {% endblock %}

{% block content %}
<style>
  pre,
  code.language-json {
    background: transparent !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  /* Remove Prism.js code shadows for all tokens */
  code[class*="language-"],
  pre[class*="language-"] {
    text-shadow: none !important;
    box-shadow: none !important;
  }

  /* Remove background from Prism.js operator tokens */
  span.token.operator {
    background: transparent !important;
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>

<div class="container">
  <h5>SPARQL Console</h5>
  <p></p>
  <div class="card caig-card" style="width: 100%;">
    <div class="card-body bg-dark text-light caig-inner-body">
      <form method="post" id="form" name="form">
        <div class="mb-3">
          <label for="sparql" class="form-label">Enter a SPARQL query:</label>
          <textarea rows='8' class="form-control" id="sparql" name="sparql" value="{{ sparql }}">{{ sparql }}</textarea>
          <script>
            var editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
              mode: "sparql",
              lineNumbers: true,
              theme: "default"
            });
            function resizeCodeMirrorToContent(cm) {
              var doc = cm.getDoc();
              var lineCount = doc.lineCount();
              var newHeight = (lineCount + 1) * 24; // 24px is the default line height
              cm.setSize(null, newHeight + "px");
            }
            resizeCodeMirrorToContent(editor);
            editor.on("change", function (cm) {
              resizeCodeMirrorToContent(cm);
            });
          </script>
        </div>
        <div class="mb-3">
          <label for="bom_query" class="form-label">Enter a name of the node, and a dependency depth number, for a graph
            visualization:</label>
          <input type="text" class="form-control" id="bom_query" name="bom_query" value="{{ bom_query }}"
            placeholder="flask 3"></input>
        </div>
        <div class="mb-6">
          <button type="submit" id="submit_button" name="submit_button"
            class="btn btn-outline-primary mb-3">Submit</button>
        </div>
        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
    </div>

    <div class="container" id="results_div" name="results_div">
      <h5>{{ results_message}}</h5>
      {% if results %}
      <pre><code class="language-json">{{ results | tojson | safe }}</code></pre> {% endif %}
      <!-- Prism.js for JSON syntax highlighting -->
      <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-sparql.min.js"></script>
      <br>
      <br>
    </div>

    <div class="container">
      <h5>{{ visualization_message }}</h5>

      <div class="container-fluid" id="d3viz" name="d3viz" style="width:95%; max-height:1024px; overflow:auto;">
        <svg style="width:100%; height:auto; display:block;" preserveAspectRatio="xMidYMid meet">
          <g></g>
        </svg>
      </div>

      <div class="invisible" id="inline_bom_json" name="inline_bom_json">
        {{ inline_bom_json }}
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block js %}
<script>
  const form = document.getElementById("form");
  const submit_button = document.getElementById("submit_button");

  submit_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      submit_button.disabled = true;
      submit_button.textContent = "Processing...";
      form.submit();
    }
  );

  $(document).ready(function () {
    var method = "{{ method }}";
    var libtype = "{{ libtype }}";
    var libtype_prefix_idx = libtype.length + 1;

    // Get the Bill-of-Materials (BOM) data that is embedded in the page.
    var bom_json = document.getElementById("inline_bom_json").innerHTML.trim().replaceAll("'", "\"");
    console.log('Raw BOM JSON:', bom_json);
    
    if (bom_json && bom_json.trim() !== '') {
      try {
        var bom_obj = JSON.parse(bom_json);
        console.log('BOM data received:', JSON.stringify(bom_obj, null, 2));

        // Transform the BOM data into a structure that is usable by D3.js to render the graph.
        var nodes = Array();
        var edges = Array();
        var nodes_set = new Set();

        // Handle the new JSON structure with 'nodes' property
        if (bom_obj.hasOwnProperty('nodes')) {
          var bom_nodes = bom_obj['nodes'];
          var node_keys = Object.keys(bom_nodes);

          for (let i = 0; i < node_keys.length; i++) {
            var node_key = node_keys[i];
            var node_data = bom_nodes[node_key];
            
            // Extract clean node name (remove URI prefix if present)
            var clean_name = node_data.name || node_key;
            if (clean_name.includes('#')) {
              clean_name = clean_name.split('#').pop();
            }
            
            console.log('Processing node:', clean_name, 'with dependencies:', node_data.dependencies);
            nodes_set.add(clean_name);

            // Process dependencies for this node
            var dependencies = node_data.dependencies;
            if (Array.isArray(dependencies)) {
              for (let d = 0; d < dependencies.length; d++) {
                var dep_uri = dependencies[d];
                var dep_clean_name = dep_uri;
                
                // Clean up dependency name (remove URI prefix if present)
                if (typeof dep_uri === 'string' && dep_uri.includes('#')) {
                  dep_clean_name = dep_uri.split('#').pop();
                }
                
                // Skip self-references and non-meaningful dependencies
                if (dep_clean_name !== clean_name && 
                    dep_clean_name.length > 0 && 
                    !dep_clean_name.match(/^\d+(\.\d+)?$/) && // Skip numeric values
                    dep_clean_name !== 'Piping' && // Skip type names
                    dep_clean_name !== 'Junction') {
                  
                  console.log('Creating edge:', clean_name, '->', dep_clean_name);
                  nodes_set.add(dep_clean_name);
                  
                  var edge = {};
                  edge["source"] = clean_name;
                  edge["target"] = dep_clean_name;
                  edge["weight"] = 1.0;
                  edges.push(edge);
                }
              }
            }
          }
        }
        // Fallback: Handle legacy 'libs' structure for backwards compatibility
        else if (bom_obj.hasOwnProperty('libs')) {
          var bom_libs = bom_obj['libs'];
          var lib_keys = Object.keys(bom_libs);

          for (let i = 0; i < lib_keys.length; i++) {
            var lib_key = lib_keys[i];
            var lib_key_tokens = lib_key.split("#");
            var lib_key_no_prefix = lib_key_tokens[1] || lib_key;
            nodes_set.add(lib_key_no_prefix);

            var dep_libs = bom_libs[lib_key]["dependencies"];
            if (Array.isArray(dep_libs)) {
              for (let d = 0; d < dep_libs.length; d++) {
                var dep_lib_uri = dep_libs[d];
                var dep_lib_uri_tokens = dep_lib_uri.split("#");
                var dep_lib_no_prefix = dep_lib_uri_tokens[1] || dep_lib_uri;
                nodes_set.add(dep_lib_no_prefix);
                
                var edge = {};
                edge["source"] = lib_key_no_prefix;
                edge["target"] = dep_lib_no_prefix;
                edge["weight"] = 1.0;
                edges.push(edge);
              }
            }
          }
        }

        // Create nodes array from the set
        nodes_set.forEach(s => {
          var n = {};
          n["name"] = s;
          n["type"] = "vertex";
          n["adjCount"] = 0;
          nodes.push(n);
        });
        
        console.log('Final nodes count:', nodes.length);
        console.log('Final edges count:', edges.length);
        console.log('Nodes:', nodes.map(n => n.name));
        console.log('Edges:', edges.map(e => e.source + ' -> ' + e.target));

        // Only generate visualization if we have nodes and edges
        if (nodes.length > 0) {
          function nodeClicked(e, d) {
            console.log("nodeClicked: " + d.name);
          }
          function nodeDblClicked(e, d) {
            console.log("nodeDblClicked: " + d.name);
          }
          function nodeMouseOver(e, d) {
            //console.log("nodeMouseOver: " + d.name);
          }
          function nodeMouseOut(e, d) {
            //console.log("nodeMouseOut: " + d.name);
          }
          function initZoom() {
            d3.select('svg').call(zoom);
          }
          function handleZoom(e) {
            console.log('handle zoom');
            d3.select('svg g').attr('transform', e.transform);
          }
          let zoom = d3.zoom().on('zoom', handleZoom);

          var typeScale = d3.scaleOrdinal()
            .domain(["library", "author", "maintainer", "vertex"])
            .range(["#75739F", "#41A368", "#FE9922", "#4A90E2"]);

          function generateGraphViz(nodes, edges) {
            console.log("generateGraphViz");

            var marker = d3.select("svg").append('defs')
              .append('marker')
              .attr("id", "Triangle")
              .attr("refX", 12)
              .attr("refY", 6)
              .attr("markerUnits", 'userSpaceOnUse')
              .attr("markerWidth", 12)
              .attr("markerHeight", 18)
              .attr("orient", 'auto')
              .append('path')
              .attr("d", 'M 0 0 12 6 0 12 3 6');

            var nodeHash = {};
            nodes.forEach(n => {
              nodeHash[n.name] = n;
            });
            edges.forEach(edge => {
              edge.weight = parseInt(edge.weight);
              edge.source = nodeHash[edge.source];
              edge.target = nodeHash[edge.target];
            });

            var linkForce = d3.forceLink(edges);

            var simulation = d3.forceSimulation()
              .force("charge", d3.forceManyBody().strength(-2000))
              .force("center", d3.forceCenter().x(800).y(500))
              .force("link", linkForce)
              .nodes(nodes)
              .on("tick", forceTick);

            simulation.force("link").links(edges);

            d3.select("svg g").selectAll("line.link")
              .data(edges, d => `${d.source.id}-${d.target.id}`)
              .enter()
              .append("line")
              .attr("class", "link")
              .style("opacity", 1.0)
              .style("stroke", "red")
              .style("stroke-width", d => d.weight);

            d3.selectAll("line").attr("marker-end", "url(#Triangle)");

            var nodeEnter = d3.select("svg g").selectAll("g.node")
              .data(nodes, d => d.name)
              .enter()
              .append("g")
              .attr("class", "node");

            nodeEnter.append("circle")
              .attr("r", 5)
              .style("fill", d => typeScale(d.type));
            nodeEnter.append("text")
              .style("text-anchor", "middle")
              .attr("y", 15)
              .text(d => d.name);

            // Register mouse event handler functions for each Node

            d3.selectAll("g.node").on("click", function (e, d) {
              nodeClicked(e, d);
            });
            d3.selectAll("g.node").on("dblclick", function (e, d) {
              nodeDblClicked(e, d);
            });
            d3.selectAll("g.node").on("mouseover", function (e, d) {
              nodeMouseOver(e, d);
            });
            d3.selectAll("g.node").on("mouseout", function (e, d) {
              nodeMouseOut(e, d);
            });

            function forceTick() {
              d3.selectAll("line.link")
                .attr("x1", d => d.source.x)
                .attr("x2", d => d.target.x)
                .attr("y1", d => d.source.y)
                .attr("y2", d => d.target.y);
              d3.selectAll("g.node")
                .attr("transform", d => `translate(${d.x},${d.y})`);
            }
            initZoom();
          }

          // Now call the function
          generateGraphViz(nodes, edges);
        } else {
          console.log('No nodes or edges found to visualize');
        }
      } catch (e) {
        console.error('Error parsing BOM JSON:', e);
        console.log('Invalid JSON content:', bom_json);
      }
    } else {
      console.log('No BOM data found');
    }
  });
</script>
{% endblock %}
