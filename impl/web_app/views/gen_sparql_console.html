{% extends "layout.html" %}
{% block title %} Generate SPARQL Console {% endblock %}

{% block content %}
<style>
  pre, code.language-json {
    background: transparent !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
  /* Remove Prism.js code shadows for all tokens */
  code[class*="language-"], pre[class*="language-"] {
    text-shadow: none !important;
    box-shadow: none !important;
  }
  /* Remove background from Prism.js operator tokens */
  span.token.operator, span.token.punctuation, span.token.url {
    background: transparent !important;
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>

<div class="container">
  <h5>Generate SPARQL Console</h5>
  <p></p>

  <form method="post" id="generate_form" name="generate_form" action="/gen_sparql_console_generate_sparql">
    <div class="mb-3">
      <label for="sparql" class="form-label">Enter your request:</label>
      <textarea rows="1" class="form-control" id="natural_language" name="natural_language" 
        placeholder="Triple-click for suggestions.">{{ natural_language }}</textarea>
    </div>
    <div class="mb-6">
      <button type="submit" id="generate_button" name="generate_button" class="btn btn-outline-primary mb-3">Generate SPARQL from Natural Language</button>
    </div>
    <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
  </form>
</div>

<div class="container">
    <p></p>
    <form method="post" id="execute_form" name="execute_form" action="/gen_sparql_console_execute_sparql">
        <div class="mb-3">
            <label for="sparql" class="form-label">SPARQL query:</label>
            <textarea id="sparql" name="sparql">{{ sparql }}</textarea>
            <script>
              var editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
                mode: "sparql",
                lineNumbers: true,
                theme: "default"
              });
              function resizeCodeMirrorToContent(cm) {
                var doc = cm.getDoc();
                var lineCount = doc.lineCount();
                var newHeight = (lineCount + 1) * 24; // 24px is the default line height
                cm.setSize(null, newHeight + "px");
              }
              resizeCodeMirrorToContent(editor);
              editor.on("change", function(cm) {
                resizeCodeMirrorToContent(cm);
              });
            </script>
        </div>

    <div class="mb-6">
      <button type="submit" id="execute_button" name="execute_button" class="btn btn-outline-primary mb-3">Execute SPARQL Query</button>
    </div>
    <input type="hidden" id="generating_nl" name="generating_nl" value="{{ generating_nl }}">
    <input type="hidden" id="execute_natural_language" name="natural_language" value="{{ natural_language }}">

        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
    </form>
</div>

<div class="container" id="results_div" name="results_div">
  <h5>{{ results_message }}</h5>
  <pre><code class="language-json">{{ results | tojson | safe }}</code></pre>
  <!-- Prism.js for JSON syntax highlighting -->
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
  <br>
  <br>
</div>

<div class="container" id="count_div" name="count_div">
  <h6>Total Results: {{ count }}</h6>
</div>
<p></p>
<p></p>

<!-- Ontology header and controls (label always visible) -->
<div class="container" id="ontology_header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
  <div style="display:flex;align-items:center;gap:12px;">
    <h5 style="margin:0;">Ontology (OWL/Turtle)</h5>
    <div id="ontology_action_controls" style="display:flex;gap:8px;align-items:center;">
      <button type="button" id="edit_owl_button" class="btn btn-sm btn-outline-secondary">Edit OWL</button>
      <button type="button" id="re_render_owl_button" class="btn btn-sm btn-outline-primary">Re-render Visualization</button>
      <span class="text-muted small">(Edit the OWL/Turtle then click Re-render)</span>
    </div>
  </div>
  <div>
  <button type="button" id="toggle_ontology_button_ctrl" class="btn btn-sm btn-outline-secondary">Hide Ontology &#9650;</button>
  </div>
</div>

<div class="container" id="owl_div" name="owl_div">
  <pre><code class="language-turtle" id="owl_code">{{ owl }}</code></pre>
  <!-- Prism.js for Turtle syntax highlighting -->
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-turtle.min.js"></script>
  <!-- rdflib for robust Turtle/OWL parsing -->
  <script src="https://cdn.jsdelivr.net/npm/rdflib/dist/rdflib.min.js"></script>
</div>

<!-- see  https://github.com/visjs/vis-network -->
<div class="container" id="ontology_div" name="ontology_div">
  <h5>Ontology Visualization</h5>
  <div class="container" id="ontology_viz" style="width:1024px;height:768px;border: 0px solid lightgray"></div>
</div>
{% endblock %}
{% block js %}
<script>

const nl_form_field   = document.getElementById("natural_language");
const generate_form   = document.getElementById("generate_form");
const generate_button = document.getElementById("generate_button");
const execute_form    = document.getElementById("execute_form");
const execute_button  = document.getElementById("execute_button");

// Triple-click handler for #natural_language
let nl_clickCount = 0;
let nl_clickTimer = null;

nl_form_field.addEventListener('click', function(event) {
  nl_clickCount++;
  if (nl_clickCount === 1) {
    nl_clickTimer = setTimeout(function() {
      nl_clickCount = 0;
    }, 400);
  } else if (nl_clickCount === 3) {
    clearTimeout(nl_clickTimer);
    nl_clickCount = 0;
    nl_query_index++;
    if (nl_query_index >= nl_queries.length) {
      nl_query_index = 0;
    }
    nl_form_field.value = nl_queries[nl_query_index];
    generate_button.disabled = false;
  }
});

var nl_query_index = -1;
var nl_queries = [
  "What is the most connected node?",
  "What entity has the most outgoing connections?",
  "How many nodes are there?",
  "How many connections are there?",
  "What are the dependencies of the flask library?",
  "What are the dependencies of the pandas library?",
  "What are the dependencies of the openai library?", 
  "what 5 libraries have the most dependencies ?"
];


generate_button.addEventListener('click', 
    function(event) {
      event.preventDefault();
      generate_button.disabled = true;
      generate_button.textContent = "Processing...";
      execute_button.disabled = true;
      generate_form.submit();
    }
);


execute_button.addEventListener('click', 
    function(event) {
      event.preventDefault();
      // Sync the current value of the textarea to the hidden input before submit
      document.getElementById('execute_natural_language').value = nl_form_field.value;
      execute_button.disabled = true;
      execute_button.textContent = "Processing...";
      generate_button.disabled = true;
      execute_form.submit();
    }
);




</script>
<!--
This <script> section was generated from an OWL file using this command:
python main_common.py owl_visualizer ontologies/libraries.owl
-->
<script type="text/javascript">
  // Dynamically build the vis.js graph from the OWL/Turtle text rendered in
  // the page under #owl_div <code> block. This keeps the view Jinja2-friendly
  // and generates nodes/edges on page load without hardcoding the graph.

  function simpleTurtleToGraph(turtleText) {
    // Very small heuristic parser: extract triples of the form
    // subject predicate object .  Handles multiple objects separated by commas.
    const nodesSet = new Map(); // id -> {id,label}
    const edges = [];

    const lines = turtleText.split(/\r?\n/);
    for (let raw of lines) {
      let line = raw.replace(/#.*$/, '').trim();
      if (!line) continue;
      // Only handle simple triple lines ending with a dot
      if (!line.endsWith('.')) continue;
      // remove trailing dot
      line = line.slice(0, -1).trim();

      // split subject, predicate, objects (objects may include commas or ';')
      const m = line.match(/^([^\s]+)\s+([^\s]+)\s+(.+)$/);
      if (!m) continue;
      let subj = m[1];
      let pred = m[2];
      let objs = m[3];

      // split objects on comma (ignore language tags / nested constructs)
      objs = objs.split(',').map(s => s.trim());

      // normalize token function: strip prefixes and angle brackets
      const norm = (token) => {
        if (!token) return token;
        // literal string
        if (token.startsWith('"') || token.startsWith("'")) return null;
        // remove trailing punctuation
        token = token.replace(/^<|>$/g, '');
        // if contains ':' return local part after ':' else return token
        if (token.indexOf(':') >= 0) {
          return token.split(':').pop();
        }
        return token;
      };

      const sId = norm(subj);
      if (sId) nodesSet.set(sId, { id: sId, label: sId });

      for (let objRaw of objs) {
        // remove predicate modifiers like ; ... (we only handle commas already split)
        // also chop off trailing whitespace or comments
        let obj = objRaw.replace(/;.*$/, '').trim();
        const oId = norm(obj);
        if (!oId) continue; // skip literals
        nodesSet.set(oId, { id: oId, label: oId });

        // derive predicate label
        const pLabel = norm(pred) || pred;
        if (!pLabel) continue;

        edges.push({ from: sId, to: oId, title: pLabel, label: pLabel });
      }
    }

    // Convert nodesSet to array
    const nodes = Array.from(nodesSet.values());
    return { nodes, edges };
  }

  async function renderOntologyGraph() {
    try {
      // get turtle text from the owl_div code block
      const codeEl = document.querySelector('#owl_div code');
      const turtleText = codeEl ? codeEl.innerText || codeEl.textContent : '';
      let graph = { nodes: [], edges: [] };
      if (turtleText && turtleText.trim().length > 0) {
        // Prefer rdflib.js parsing for correctness; fallback to heuristic parser
        try {
          // rdflibToGraph returns a Promise
          graph = await rdflibToGraph(turtleText);
          // If rdflib produced no nodes, fall back
          if (!graph || !graph.nodes || graph.nodes.length === 0) {
            graph = simpleTurtleToGraph(turtleText);
          }
        } catch (e) {
          console.warn('rdflib parsing failed, falling back to heuristic parser:', e);
          graph = simpleTurtleToGraph(turtleText);
        }
      }

      // fallback if parse produced no nodes
      if (!graph.nodes.length) {
        graph = {
          nodes: [ { id: 'Dev', label: 'Dev' }, { id: 'Doc', label: 'Doc' }, { id: 'Lib', label: 'Lib' } ],
          edges: [ { from: 'Dev', to: 'Lib', title: 'developer_of' }, { from: 'Lib', to: 'Dev', title: 'developed_by' }, { from: 'Lib', to: 'Lib', title: 'used_by_lib, uses_lib' } ]
        };
      }

      // create vis DataSets
      const nodes = new vis.DataSet(graph.nodes.map(n => ({ id: n.id, label: n.label })));
      const edges = new vis.DataSet(graph.edges.map(e => ({ from: e.from, to: e.to, label: e.label, title: e.title })));

      const html_container = document.getElementById('ontology_viz');
      const graph_data = { nodes: nodes, edges: edges };
      const graph_options = {
        edges: {
          arrows: { to: { enabled: true, scaleFactor: 0.2, type: 'arrow' } },
          color: '#A9A9A9',
          font: '12px arial #A9A9A9',
          scaling: { label: true },
          shadow: false,
          smooth: true,
        },
        physics: { enabled: true, repulsion: { centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 200, damping: 0.09 } }
      };

      // clear previous network if present
      if (window.__ontology_network) {
        try { window.__ontology_network.destroy(); } catch (e) {}
      }
      window.__ontology_network = new vis.Network(html_container, graph_data, graph_options);
    } catch (e) {
      console.error('Error rendering ontology graph:', e);
    }
  }

  // rdflib-based parser: returns {nodes:[], edges:[]} using basic heuristics
  function rdflibToGraph(turtleText) {
    if (typeof $rdf === 'undefined') {
      throw new Error('rdflib not loaded');
    }
    const store = $rdf.graph();
    const mime = 'text/turtle';
    // base URI for relative IRIs
    const base = 'http://example.org/base#';
    return new Promise((resolve, reject) => {
      try {
        $rdf.parse(turtleText, store, base, mime, function(err, kb) {
          if (err) {
            // rdflib uses callback with err
            reject(err);
            return;
          }
          // collect nodes and edges
          const nodesMap = new Map();
          const edges = [];
          const statements = store.statementsMatching(undefined, undefined, undefined, undefined);
          statements.forEach(st => {
            const s = termToId(st.subject);
            const p = termToId(st.predicate);
            const o = termToId(st.object);
            if (s) nodesMap.set(s, { id: s, label: s });
            if (o) nodesMap.set(o, { id: o, label: o });
            if (s && o) {
              edges.push({ from: s, to: o, title: p, label: p });
            }
          });
          resolve({ nodes: Array.from(nodesMap.values()), edges: edges });
        });
      } catch (ex) {
        reject(ex);
      }
    });

    function termToId(term) {
      if (!term) return null;
      if (term.termType === 'Literal') return null;
      if (term.termType === 'BlankNode') return '_:' + term.value;
      // URIRef: try to shorten by last fragment or path
      let v = term.value;
      // if contains '#', use substring after
      if (v.indexOf('#') >= 0) return v.split('#').pop();
      // else use last path segment
      const parts = v.split('/');
      return parts[parts.length - 1] || v;
    }
  }

  // Run on DOMContentLoaded to ensure code block is present
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      try {
        // read stored visibility state (session) - default: hidden
        const stored = sessionStorage.getItem('ontologyVisible');
        const visible = stored === null ? false : stored === 'true';
        const owlDiv = document.getElementById('owl_div');
        const ontDiv = document.getElementById('ontology_div');
        const actionControls = document.getElementById('ontology_action_controls');
        const toggleBtn = document.getElementById('toggle_ontology_button_ctrl');
        if (owlDiv) owlDiv.style.display = visible ? '' : 'none';
        if (ontDiv) ontDiv.style.display = visible ? '' : 'none';
        if (actionControls) actionControls.style.display = visible ? 'flex' : 'none';
        if (toggleBtn) toggleBtn.innerHTML = visible ? 'Hide Ontology &#9650;' : 'Show Ontology &#9660;';
        // render only when visible
        if (visible) renderOntologyGraph().catch(e => console.error(e));
      } catch (e) {
        console.error('Init error:', e);
        renderOntologyGraph().catch(e2 => console.error(e2));
      }
    });
  } else {
    try {
      const stored = sessionStorage.getItem('ontologyVisible');
      const visible = stored === null ? false : stored === 'true';
      const owlDiv = document.getElementById('owl_div');
      const ontDiv = document.getElementById('ontology_div');
      const actionControls = document.getElementById('ontology_action_controls');
      const toggleBtn = document.getElementById('toggle_ontology_button_ctrl');
      if (owlDiv) owlDiv.style.display = visible ? '' : 'none';
      if (ontDiv) ontDiv.style.display = visible ? '' : 'none';
      if (actionControls) actionControls.style.display = visible ? 'flex' : 'none';
      if (toggleBtn) toggleBtn.innerHTML = visible ? 'Hide Ontology &#9650;' : 'Show Ontology &#9660;';
      if (visible) renderOntologyGraph().catch(e => console.error(e));
    } catch (e) {
      console.error('Init error:', e);
      renderOntologyGraph().catch(e2 => console.error(e2));
    }
  }
  // Edit / Re-render UI wiring
  (function() {
  const editBtn = document.getElementById('edit_owl_button');
  const rerenderBtn = document.getElementById('re_render_owl_button');
  const toggleBtn = document.getElementById('toggle_ontology_button_ctrl');
    const codeBlock = document.getElementById('owl_code');
    let textarea = null;

  // initialize visibility from sessionStorage or current DOM (default: hidden)
  let ontologyVisible = (function() {
    try {
      const stored = sessionStorage.getItem('ontologyVisible');
      if (stored !== null) return stored === 'true';
    } catch (e) {}
    const owlDivInit = document.getElementById('owl_div');
    if (owlDivInit) return owlDivInit.style.display !== 'none';
    return false;
  })();

    function enterEditMode() {
      if (textarea) return;
      textarea = document.createElement('textarea');
      textarea.id = 'owl_edit_textarea';
      textarea.style.width = '100%';
      textarea.style.minHeight = '240px';
      textarea.value = codeBlock ? codeBlock.innerText : '';
      codeBlock.parentNode.replaceChild(textarea, codeBlock);
      editBtn.textContent = 'Done Editing';
    }

    function exitEditMode() {
      if (!textarea) return;
      const newCode = document.createElement('code');
      newCode.id = 'owl_code';
      newCode.className = 'language-turtle';
      newCode.textContent = textarea.value;
      textarea.parentNode.replaceChild(newCode, textarea);
      // re-run Prism highlight (if available)
      try { if (window.Prism) Prism.highlightElement(newCode); } catch (e) {}
      textarea = null;
      editBtn.textContent = 'Edit OWL';
    }

    editBtn.addEventListener('click', function() {
      if (textarea) {
        exitEditMode();
      } else {
        enterEditMode();
      }
    });

  rerenderBtn.addEventListener('click', function() {
      // if in edit mode, update the code block from textarea first
      if (textarea) {
        // replace textarea with code block temporarily so renderer finds it
        const tempCode = document.createElement('code');
        tempCode.id = 'owl_code';
        tempCode.className = 'language-turtle';
        tempCode.textContent = textarea.value;
        textarea.parentNode.replaceChild(tempCode, textarea);
        try { if (window.Prism) Prism.highlightElement(tempCode); } catch (e) {}
        // set textarea back (so user can keep editing) after render
        setTimeout(() => {
          if (tempCode.parentNode) tempCode.parentNode.replaceChild(textarea, tempCode);
        }, 10);
      }
  // call the existing render function (async)
  try { renderOntologyGraph().catch(e => console.error('Re-render failed:', e)); } catch (e) { console.error('Re-render failed:', e); }
    });

      toggleBtn.addEventListener('click', function() {
        ontologyVisible = !ontologyVisible;
        const owlDiv = document.getElementById('owl_div');
        const ontDiv = document.getElementById('ontology_div');
        const actionControls = document.getElementById('ontology_action_controls');
        // hide only the content, visualization, and action buttons; keep header and toggle visible
        if (owlDiv) owlDiv.style.display = ontologyVisible ? '' : 'none';
        if (ontDiv) ontDiv.style.display = ontologyVisible ? '' : 'none';
        if (actionControls) actionControls.style.display = ontologyVisible ? 'flex' : 'none';
        toggleBtn.innerHTML = ontologyVisible ? 'Hide Ontology &#9650;' : 'Show Ontology &#9660;';
        try { sessionStorage.setItem('ontologyVisible', ontologyVisible ? 'true' : 'false'); } catch (e) {}
        // when showing, ensure visualization is (re)rendered
        if (ontologyVisible) {
          try { renderOntologyGraph().catch(e => console.error('Render after show failed:', e)); } catch (e) { console.error(e); }
        }
      });
  })();
</script>

{% endblock %}
