{% extends "layout.html" %}
{% block title %} NL2SPARQL Console {% endblock %}

{% block content %}
<style>
  /* Lucida Console font for ontology visualization (vis.js network) */
  #ontology_viz .vis-network .vis-label {
    font-family: "Lucida Console", "Courier New", monospace !important;
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/turtle/turtle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/xml/xml.min.js"></script>

<div class="container">
  <h5>Natural Language-to-SPARQL Playground</h5>
  <p></p>
  <div class="card caig-card" style="width: 100%;">
    <div class="card-body bg-dark text-light caig-inner-body">
      <form method="post" id="generate_form" name="generate_form" action="/gen_sparql_console_generate_sparql">
        <div class="mb-3">
          <label for="sparql" class="form-label">Natural language request:</label>
          <textarea rows="1" class="form-control" id="natural_language" name="natural_language"
            placeholder="Triple-click for suggestions.">{{ natural_language }}</textarea>
          <script>
            function autoResizeTextarea(textarea) {
              // Reset height to auto to get the correct scrollHeight
              textarea.style.height = 'auto';
              // Set height based on scrollHeight, with minimum of 1 row (approximately 38px)
              const minHeight = 38; // Approximate height for 1 row
              const newHeight = Math.max(minHeight, textarea.scrollHeight);
              textarea.style.height = newHeight + 'px';
            }
            
            // Auto-resize on page load
            const nlTextarea = document.getElementById('natural_language');
            autoResizeTextarea(nlTextarea);
            
            // Auto-resize on input
            nlTextarea.addEventListener('input', function() {
              autoResizeTextarea(this);
            });
          </script>
        </div>
        <div class="mb-6">
          <button type="submit" id="generate_button" name="generate_button"
            class="btn btn-outline-primary mb-3">Generate SPARQL</button>
        </div>
        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
      <p></p>

      <form method="post" id="execute_form" name="execute_form" action="/gen_sparql_console_execute_sparql">
        <div class="mb-3">
          <label for="sparql" class="form-label">SPARQL query:</label>
          <textarea id="sparql" name="sparql">{{ sparql }}</textarea>
          <script>
            // Create global CodeMirror editor instance
            window.editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
              mode: "sparql",
              lineNumbers: true,
              theme: "default"
            });
            function resizeCodeMirrorToContent(cm) {
              var doc = cm.getDoc();
              var lineCount = doc.lineCount();
              var newHeight = (lineCount + 1) * 24; // 24px is the default line height
              cm.setSize(null, newHeight + "px");
            }
            resizeCodeMirrorToContent(window.editor);
            window.editor.on("change", function (cm) {
              resizeCodeMirrorToContent(cm);
            });
          </script>
        </div>

        <div class="mb-6">
          <button type="submit" id="execute_button" name="execute_button" class="btn btn-outline-primary mb-3">Execute
            SPARQL</button>
        </div>
        <input type="hidden" id="generating_nl" name="generating_nl" value="{{ generating_nl }}">
        <input type="hidden" id="execute_natural_language" name="natural_language" value="{{ natural_language }}">

        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
    </div>

    <div class="container" id="results_div" name="results_div">
      <div class="d-flex justify-content-between align-items-center">
        <h5>{{ results_message }}</h5>
        {% if count and count > 0 %}
        <h6 class="text-muted mb-0">Total Results: {{ count }}</h6>
        {% endif %}
      </div>
      {% if results %}
      <pre><code class="language-json">{{ results | tojson | safe }}</code></pre> {% endif %}
      <!-- Prism.js for JSON syntax highlighting -->
      <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
      <br/>
    </div>

    <!-- Ontology header and controls (label always visible) -->
    <div class="container" id="ontology_header"
      style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;margin-top:0;">
      <div style="display:flex;align-items:center;gap:12px;">
        <h5 style="margin:0;">Ontology (OWL/Turtle)</h5>
        <div id="ontology_action_controls" style="display:flex;gap:8px;align-items:center;">
          <button type="button" id="edit_owl_button" class="btn btn-sm btn-outline-secondary">Edit</button>
          <!-- Save button removed -->
        </div>
      </div>
      <div>
        <button type="button" id="toggle_ontology_button_ctrl" class="btn btn-sm btn-outline-secondary">Hide Ontology
          &#9650;</button>
      </div>
    </div>
    <br/>
    <div class="container" id="owl_div" name="owl_div">
      <pre><code class="language-turtle" id="owl_code" style="font-size: 12px;">{{ owl }}</code></pre>
      <!-- Prism.js for Turtle and XML syntax highlighting -->
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-turtle.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-xml-doc.min.js"></script>
      <!-- rdflib for robust Turtle/OWL parsing -->
      <script src="https://cdn.jsdelivr.net/npm/rdflib/dist/rdflib.min.js"></script>
    </div>

    <!-- see  https://github.com/visjs/vis-network -->
    <div class="container" id="ontology_div" name="ontology_div">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
        <h5 style="margin:0;">Ontology Visualization</h5>
        <div id="ontology_viz_controls" style="display:flex;gap:8px;align-items:center;">
          <button type="button" id="re_render_owl_button" class="btn btn-sm btn-outline-primary">Re-render</button>
        </div>
      </div>
      <div class="container" id="ontology_viz" style="width:100%;height:768px;border: 0px solid lightgray"></div>
    </div>


  </div>
</div>

{% endblock %}
{% block js %}
<script>

  const nl_form_field = document.getElementById("natural_language");
  const generate_form = document.getElementById("generate_form");
  const generate_button = document.getElementById("generate_button");
  const execute_form = document.getElementById("execute_form");
  const execute_button = document.getElementById("execute_button");

  // Triple-click handler for #natural_language
  let nl_clickCount = 0;
  let nl_clickTimer = null;

  nl_form_field.addEventListener('click', function (event) {
    nl_clickCount++;
    if (nl_clickCount === 1) {
      nl_clickTimer = setTimeout(function () {
        nl_clickCount = 0;
      }, 400);
    } else if (nl_clickCount === 3) {
      clearTimeout(nl_clickTimer);
      nl_clickCount = 0;
      nl_query_index++;
      if (nl_query_index >= nl_queries.length) {
        nl_query_index = 0;
      }
      nl_form_field.value = nl_queries[nl_query_index];
      generate_button.disabled = false;
    }
  });

  var nl_query_index = -1;
  var nl_queries = [
    "What is the most connected node?",
    "What entity has the most outgoing connections?",
    "How many nodes are there?",
    "How many connections are there?",
    "What are the dependencies of the flask library?",
    "What are the dependencies of the pandas library?",
    "What are the dependencies of the openai library?",
    "what 5 libraries have the most dependencies ?"
  ];


  // Local Storage Management for form inputs
  const STORAGE_KEYS = {
    naturalLanguage: 'gen_sparql_console_natural_language',
    sparqlQuery: 'gen_sparql_console_sparql_query'
  };

  // Load saved values from localStorage
  function loadFromLocalStorage() {
    try {
      // Check if we just submitted a form (new content from backend)
      const formSubmitted = sessionStorage.getItem('gen_sparql_form_submitted');
      
      // Load natural language query (always restore this)
      const savedNaturalLanguage = localStorage.getItem(STORAGE_KEYS.naturalLanguage);
      if (savedNaturalLanguage && nl_form_field) {
        nl_form_field.value = savedNaturalLanguage;
        // Trigger auto-resize
        if (typeof autoResizeTextarea === 'function') {
          autoResizeTextarea(nl_form_field);
        }
      }

      // Only load SPARQL query if we didn't just submit a form
      // (to avoid overriding newly generated content from backend)
      if (!formSubmitted) {
        const savedSparqlQuery = localStorage.getItem(STORAGE_KEYS.sparqlQuery);
        if (savedSparqlQuery && window.editor) {
          window.editor.setValue(savedSparqlQuery);
        }
      } else {
        // Clear the submission flag after handling it
        sessionStorage.removeItem('gen_sparql_form_submitted');
      }
    } catch (e) {
      console.warn('Error loading from localStorage:', e);
    }
  }

  // Save values to localStorage
  function saveToLocalStorage() {
    try {
      // Save natural language query
      if (nl_form_field) {
        localStorage.setItem(STORAGE_KEYS.naturalLanguage, nl_form_field.value);
      }

      // Save SPARQL query (CodeMirror editor)
      if (window.editor) {
        localStorage.setItem(STORAGE_KEYS.sparqlQuery, window.editor.getValue());
      }
    } catch (e) {
      console.warn('Error saving to localStorage:', e);
    }
  }

  // Set up event listeners for auto-saving
  function setupAutoSave() {
    // Auto-save natural language input changes
    if (nl_form_field) {
      nl_form_field.addEventListener('input', saveToLocalStorage);
      nl_form_field.addEventListener('blur', saveToLocalStorage);
    }

    // Auto-save SPARQL editor changes
    if (window.editor) {
      window.editor.on('change', function() {
        saveToLocalStorage();
      });
    }
  }

  // Initialize localStorage functionality
  document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for CodeMirror to be fully initialized
    setTimeout(function() {
      loadFromLocalStorage();
      setupAutoSave();
    }, 100);
  });

  generate_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      generate_button.disabled = true;
      generate_button.textContent = "Processing...";
      execute_button.disabled = true;
      // Save current values before submit
      saveToLocalStorage();
      // Mark that we're submitting a form to prevent localStorage restoration
      sessionStorage.setItem('gen_sparql_form_submitted', 'true');
      generate_form.submit();
    }
  );


  execute_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      // Sync the current value of the textarea to the hidden input before submit
      document.getElementById('execute_natural_language').value = nl_form_field.value;
      execute_button.disabled = true;
      execute_button.textContent = "Processing...";
      generate_button.disabled = true;
      // Save current values before submit
      saveToLocalStorage();
      execute_form.submit();
    }
  );



</script>
<!--
This <script> section was generated from an OWL file using this command:
python main_common.py owl_visualizer ontologies/libraries.owl
-->
<script type="text/javascript">
  // Dynamically build the vis.js graph from the OWL/Turtle text rendered in
  // the page under #owl_div <code> block. This keeps the view Jinja2-friendly
  // and generates nodes/edges on page load without hardcoding the graph.

  function simpleTurtleToGraph(turtleText) {
    // Very small heuristic parser: extract triples of the form
    // subject predicate object .  Handles multiple objects separated by commas.
    const nodesSet = new Map(); // id -> {id,label}
    const edges = [];

    const lines = turtleText.split(/\r?\n/);
    for (let raw of lines) {
      let line = raw.replace(/#.*$/, '').trim();
      if (!line) continue;
      // Only handle simple triple lines ending with a dot
      if (!line.endsWith('.')) continue;
      // remove trailing dot
      line = line.slice(0, -1).trim();

      // split subject, predicate, objects (objects may include commas or ';')
      const m = line.match(/^([^\s]+)\s+([^\s]+)\s+(.+)$/);
      if (!m) continue;
      let subj = m[1];
      let pred = m[2];
      let objs = m[3];

      // split objects on comma (ignore language tags / nested constructs)
      objs = objs.split(',').map(s => s.trim());

      // normalize token function: strip prefixes and angle brackets
      const norm = (token) => {
        if (!token) return token;
        // literal string
        if (token.startsWith('"') || token.startsWith("'")) return null;
        // remove trailing punctuation
        token = token.replace(/^<|>$/g, '');
        // if contains ':' return local part after ':' else return token
        if (token.indexOf(':') >= 0) {
          return token.split(':').pop();
        }
        return token;
      };

      const sId = norm(subj);
      if (sId) nodesSet.set(sId, { id: sId, label: sId });

      for (let objRaw of objs) {
        // remove predicate modifiers like ; ... (we only handle commas already split)
        // also chop off trailing whitespace or comments
        let obj = objRaw.replace(/;.*$/, '').trim();
        const oId = norm(obj);
        if (!oId) continue; // skip literals
        nodesSet.set(oId, { id: oId, label: oId });

        // derive predicate label
        const pLabel = norm(pred) || pred;
        if (!pLabel) continue;

        edges.push({ from: sId, to: oId, title: pLabel, label: pLabel });
      }
    }

    // Convert nodesSet to array
    const nodes = Array.from(nodesSet.values());
    return { nodes, edges };
  }

  async function renderOntologyGraph() {
    try {
      // get turtle text from the owl_div code block
      const codeEl = document.querySelector('#owl_div code');
      const turtleText = codeEl ? codeEl.innerText || codeEl.textContent : '';
      let graph = { nodes: [], edges: [] };
      if (turtleText && turtleText.trim().length > 0) {
        // Prefer rdflib.js parsing for correctness; fallback to heuristic parser
        try {
          // rdflibToGraph returns a Promise
          graph = await rdflibToGraph(turtleText);
          // If rdflib produced no nodes, fall back
          if (!graph || !graph.nodes || graph.nodes.length === 0) {
            graph = simpleTurtleToGraph(turtleText);
          }
        } catch (e) {
          console.warn('rdflib parsing failed, falling back to heuristic parser:', e);
          graph = simpleTurtleToGraph(turtleText);
        }
      }

      // fallback if parse produced no nodes
      // Performance optimization: define thresholds for vis.js
      const LARGE_ONTOLOGY_THRESHOLD = 50;
      const HUGE_ONTOLOGY_THRESHOLD = 150;
      const isLargeOntology = graph.nodes.length > LARGE_ONTOLOGY_THRESHOLD;
      const isHugeOntology = graph.nodes.length > HUGE_ONTOLOGY_THRESHOLD;

      if (graph.nodes.length > 0) {
        console.log(`Rendering ${isLargeOntology ? 'LARGE' : 'NORMAL'} ontology with`, graph.nodes.length, 'nodes and', graph.edges.length, 'edges');
      }

      // Filter edges for huge ontologies to reduce complexity
      let displayEdges = graph.edges;
      if (isHugeOntology && graph.edges.length > 0) {
        // Keep only the most important relationships for huge ontologies
        displayEdges = graph.edges.filter(edge => 
          edge.label && (
            edge.label.includes('subClassOf') || 
            edge.label.includes('type') || 
            edge.label.includes('domain') || 
            edge.label.includes('range') ||
            edge.label.length < 15 // Keep short, likely important relationships
          )
        );
        console.log(`Filtered ontology edges for performance: ${graph.edges.length} -> ${displayEdges.length}`);
      }

      if (!graph.nodes.length) {
        graph = {
          nodes: [{ id: 'Dev', label: 'Dev' }, { id: 'Doc', label: 'Doc' }, { id: 'Lib', label: 'Lib' }],
          edges: [{ from: 'Dev', to: 'Lib', title: 'developer_of' }, { from: 'Lib', to: 'Dev', title: 'developed_by' }, { from: 'Lib', to: 'Lib', title: 'used_by_lib, uses_lib' }]
        };
        displayEdges = graph.edges;
      }

      // create vis DataSets
      // Generate random dark color for each node
      function randomDarkColor() {
        // HSL: hue random, sat 40-60%, lightness 15-30%
        const h = Math.floor(Math.random() * 360);
        const s = 40 + Math.floor(Math.random() * 20);
        const l = 15 + Math.floor(Math.random() * 15);
        return `hsl(${h},${s}%,${l}%)`;
      }
      const nodes = new vis.DataSet(graph.nodes.map((n) => {
        const color = randomDarkColor();
        return {
          id: n.id,
          label: isLargeOntology && n.label.length > 15 ? n.label.substring(0, 15) + '...' : n.label,
          title: n.label, // Full label in tooltip
          shape: "box",
          color: {
            background: color,
            border: color,
            highlight: { background: color, border: color },
            hover: { background: color, border: color }
          },
          font: {
            color: "#fff",
            size: isLargeOntology ? 14 : 18,
            face: 'Lucida Console',
            bold: !isLargeOntology // Remove bold for large ontologies
          },
          borderWidth: 0,
          margin: isLargeOntology ? 5 : 10
        };
      }));
      
      // Only show edge labels for smaller ontologies or important edges
      const edges = new vis.DataSet(displayEdges.map(e => ({
        from: e.from,
        to: e.to,
        label: (isLargeOntology && e.label && e.label.length > 10) ? '' : e.label, // Hide labels for long text in large graphs
        title: e.title || e.label, // Keep full label in tooltip
        font: {
          color: "#90caf9",
          strokeWidth: 0,
          size: isLargeOntology ? 10 : 12,
          face: 'Lucida Console',
          align: 'middle',
          vadjust: -8
        },
        color: {
          color: "#b0bec5",
          highlight: "#90caf9",
          hover: "#90caf9"
        },
        arrows: { to: { enabled: true, scaleFactor: isLargeOntology ? 0.15 : 0.2, type: 'arrow' } },
        smooth: {
          enabled: !isHugeOntology, // Disable smooth curves for huge graphs
          type: isLargeOntology ? "continuous" : "dynamic"
        },
        shadow: false,
        width: isLargeOntology ? 1 : 2
      })));
      const html_container = document.getElementById('ontology_viz');
      const graph_data = { nodes: nodes, edges: edges };
      const graph_options = {
        nodes: {
          shape: "box",
          borderWidth: 0,
          margin: isLargeOntology ? 5 : 10,
          font: {
            size: isLargeOntology ? 14 : 18,
            face: 'Lucida Console',
            bold: !isLargeOntology,
            color: "#fff"
          }
        },
        edges: {
          arrows: { to: { enabled: true, scaleFactor: isLargeOntology ? 0.15 : 0.2, type: 'arrow' } },
          color: "#b0bec5",
          font: {
            color: "#90caf9",
            strokeWidth: 0,
            size: isLargeOntology ? 10 : 12,
            face: 'Lucida Console',
            align: 'middle',
            vadjust: -8
          },
          scaling: { label: !isLargeOntology }, // Disable label scaling for large graphs
          shadow: false,
          smooth: {
            enabled: !isHugeOntology,
            type: isLargeOntology ? "continuous" : "dynamic"
          },
          width: isLargeOntology ? 1 : 2
        },
        physics: { 
          enabled: true, 
          // Performance tuning for different graph sizes
          repulsion: { 
            centralGravity: isLargeOntology ? 0.1 : 0.2, 
            springLength: isLargeOntology ? 150 : 200, 
            springConstant: isLargeOntology ? 0.03 : 0.05, 
            nodeDistance: isLargeOntology ? 150 : 200, 
            damping: isLargeOntology ? 0.15 : 0.09 
          },
          // Stabilization options for large graphs
          stabilization: {
            enabled: true,
            iterations: isLargeOntology ? 100 : 200, // Fewer iterations for large graphs
            updateInterval: isLargeOntology ? 10 : 5, // Less frequent updates for large graphs
            onlyDynamicEdges: false,
            fit: true
          },
          // Adaptive timestep for better performance
          adaptiveTimestep: isLargeOntology,
          minVelocity: isLargeOntology ? 10 : 0.75,
          maxVelocity: isLargeOntology ? 30 : 50
        },
        // Performance settings
        interaction: {
          dragNodes: !isHugeOntology, // Disable dragging for huge graphs
          dragView: true,
          zoomView: true,
          selectConnectedEdges: !isLargeOntology, // Disable for performance in large graphs
          hover: !isHugeOntology, // Disable hover effects for huge graphs
          hoverConnectedEdges: false // Always disable for performance
        },
        layout: {
          improvedLayout: !isHugeOntology, // Disable improved layout for huge graphs
          randomSeed: isLargeOntology ? 42 : undefined // Consistent layout for large graphs
        }
      };

      // Clear previous network if present
      if (window.__ontology_network) {
        try { 
          window.__ontology_network.destroy(); 
          // Allow garbage collection
          window.__ontology_network = null;
        } catch (e) { 
          console.warn('Failed to destroy previous network:', e);
        }
      }

      // Create network with performance monitoring
      const startTime = performance.now();
      window.__ontology_network = new vis.Network(html_container, graph_data, graph_options);
      
      // Performance monitoring and optimization
      if (isLargeOntology) {
        // Set up event listeners for performance monitoring
        window.__ontology_network.on("stabilizationProgress", function(params) {
          const progress = Math.round((params.iterations / params.total) * 100);
          if (progress % 20 === 0) { // Log every 20%
            console.log(`Stabilization progress: ${progress}%`);
          }
        });

        window.__ontology_network.on("stabilized", function() {
          const endTime = performance.now();
          console.log(`Large ontology stabilized in ${Math.round(endTime - startTime)}ms`);
        });

        // Limit animation for large graphs
        window.__ontology_network.setOptions({
          physics: {
            ...graph_options.physics,
            // Stop physics after stabilization for large graphs
            enabled: false
          }
        });
        
        // Enable physics only temporarily for initial layout
        setTimeout(() => {
          if (window.__ontology_network) {
            window.__ontology_network.setOptions({
              physics: { enabled: false }
            });
            console.log('Physics disabled for large ontology after initial layout');
          }
        }, 3000);
      } else {
        window.__ontology_network.on("stabilized", function() {
          const endTime = performance.now();
          console.log(`Ontology rendered in ${Math.round(endTime - startTime)}ms`);
        });
      }
    } catch (e) {
      console.error('Error rendering ontology graph:', e);
    }
  }

  // Initial render
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
      renderOntologyGraph();
    }, 100);
  });

  // Re-render on button click
  document.getElementById('re_render_owl_button').addEventListener('click', function () {
    renderOntologyGraph();
  });



  // Unified ontology edit/save/toggle logic
  (function() {
    const editBtn      = document.getElementById('edit_owl_button');
    const toggleBtn    = document.getElementById('toggle_ontology_button_ctrl');
    const rerenderBtn  = document.getElementById('re_render_owl_button');
    const owlDiv       = document.getElementById('owl_div');
    const ontDiv       = document.getElementById('ontology_div');
    const actionCtrls  = document.getElementById('ontology_action_controls');
    let owlEditor = null;

    function detectOntologyFormat(content) {
      if (!content) return 'turtle';
      const t = content.trim();
      if (t.startsWith('<?xml') || t.startsWith('<rdf:RDF') || t.includes('<owl:') || t.includes('xmlns:owl=')
          || t.includes('xmlns:rdf=')) return 'xml';
      if (t.includes('@prefix') || t.includes('@base') || /(^|\s)PREFIX\s/i.test(t) || /\s+a\s+/.test(t))
        return 'turtle';
      return 'turtle';
    }
    function resizeEditor(cm) {
      const lc = cm.getDoc().lineCount();
      cm.setSize(null, Math.max((lc + 1) * 24, 240) + 'px');
    }
    function enterEditMode() {
      if (owlEditor) return;
      const codeBlock = document.getElementById('owl_code');
      if (!codeBlock) return;
      const content = codeBlock.textContent;
      const format = detectOntologyFormat(content);
      const ta = document.createElement('textarea');
      ta.id = 'owl_edit_textarea';
      ta.style.width = '100%';
      ta.style.minHeight = '240px';
      ta.value = content;
      codeBlock.parentNode.replaceChild(ta, codeBlock);
      owlEditor = CodeMirror.fromTextArea(ta, {
        mode: format === 'xml' ? 'xml' : 'turtle',
        lineNumbers: true,
        theme: 'default'
      });
      resizeEditor(owlEditor);
      owlEditor.on('change', resizeEditor);
      editBtn.textContent = 'Save';
    }
    function exitEditMode(replacementContent) {
      if (!owlEditor) return;
      const content = replacementContent !== undefined ? replacementContent : owlEditor.getValue();
      const format = detectOntologyFormat(content);
      const newCode = document.createElement('code');
      newCode.id = 'owl_code';
      newCode.className = format === 'xml' ? 'language-xml' : 'language-turtle';
      newCode.style.fontSize = '12px';
      newCode.textContent = content;
      const wrapper = owlEditor.getWrapperElement();
      wrapper.parentNode.replaceChild(newCode, wrapper);
      try { if (window.Prism) Prism.highlightElement(newCode); } catch(e){}
      owlEditor = null;
      editBtn.textContent = 'Edit';
    }
    function saveOntology() {
      if (!owlEditor) return;
      const content = owlEditor.getValue();
      editBtn.disabled = true;
      const priorLabel = editBtn.textContent;
      editBtn.textContent = 'Saving...';
      fetch('/api/save_ontology', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ content })
      })
      .then(r => r.json())
      .then(j => {
        if (j.success) {
          alert('Ontology saved.');
          exitEditMode(content);
        } else {
          console.error('Save ontology failed:', j);
          alert('Save failed: ' + (j.error || 'Unknown error'));
          // Keep in edit mode so user can retry (do NOT exit)
          editBtn.textContent = 'Retry Save';
        }
      })
      .catch(e => {
        console.error('Save ontology network/error:', e);
        alert('Save failed: ' + e);
        editBtn.textContent = 'Retry Save';
      })
      .finally(() => {
        editBtn.disabled = false;
        if (!owlEditor && editBtn.textContent !== 'Edit') {
          // If we exited edit mode successfully, ensure label is Edit
          editBtn.textContent = 'Edit';
        }
        if (owlEditor && editBtn.textContent === 'Saving...') {
          // If still in edit mode but no label update happened, restore to Retry Save
          editBtn.textContent = 'Retry Save';
        }
      });
    }

    editBtn.addEventListener('click', function(e) {
      e.preventDefault();
      if (!owlEditor) {
        enterEditMode();
      } else {
        saveOntology();
      }
    });

    toggleBtn.addEventListener('click', function(e) {
      e.preventDefault();
      const visible = owlDiv.style.display !== 'none';
      const newVisible = !visible;
      owlDiv.style.display = newVisible ? '' : 'none';
      ontDiv.style.display = newVisible ? '' : 'none';
      actionCtrls.style.display = newVisible ? 'flex' : 'none';
      toggleBtn.innerHTML = newVisible ? 'Hide &#9650;' : 'Show &#9660;';
      try { sessionStorage.setItem('ontologyVisible', newVisible.toString()); } catch(e){}
      if (newVisible) renderOntologyGraph();
    });

    // Restore persisted visibility
    (function restoreVisibility() {
      let vis = true;
      try {
        const stored = sessionStorage.getItem('ontologyVisible');
        if (stored === 'false') vis = false;
      } catch(e){}
      if (!vis) {
        owlDiv.style.display = 'none';
        ontDiv.style.display = 'none';
        actionCtrls.style.display = 'none';
        toggleBtn.innerHTML = 'Show &#9660;';
      } else {
        toggleBtn.innerHTML = 'Hide &#9650;';
      }
    })();

    rerenderBtn.addEventListener('click', function(e) {
      e.preventDefault();
      if (owlEditor) {
        // temporarily get content for graph parse
        const content = owlEditor.getValue();
        exitEditMode(content);
        renderOntologyGraph();
        enterEditMode();
      } else {
        renderOntologyGraph();
      }
    });
  })();
</script>

{% endblock %}