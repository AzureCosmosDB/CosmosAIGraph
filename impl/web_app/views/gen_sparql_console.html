{% extends "layout.html" %}
{% block title %} NL2SPARQL Console {% endblock %}

{% block content %}
<style>
  /* Lucida Console font for ontology visualization (vis.js network) */
  #ontology_viz .vis-network .vis-label {
    font-family: "Lucida Console", "Courier New", monospace !important;
  }
</style>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/turtle/turtle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/xml/xml.min.js"></script>

<div class="container">
  <h5>Natural Language-to-SPARQL Playground</h5>
  <p></p>
  <div class="card caig-card" style="width: 100%;">
    <div class="card-body bg-dark text-light caig-inner-body">
      <form method="post" id="generate_form" name="generate_form" action="/gen_sparql_console_generate_sparql">
        <div class="mb-3">
          <label for="sparql" class="form-label">Natural language request:</label>
          <textarea rows="1" class="form-control" id="natural_language" name="natural_language"
            placeholder="Triple-click for suggestions.">{{ natural_language }}</textarea>
        </div>
        <div class="mb-6">
          <button type="submit" id="generate_button" name="generate_button"
            class="btn btn-outline-primary mb-3">Generate SPARQL</button>
        </div>
        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
      <p></p>

      <form method="post" id="execute_form" name="execute_form" action="/gen_sparql_console_execute_sparql">
        <div class="mb-3">
          <label for="sparql" class="form-label">SPARQL query:</label>
          <textarea id="sparql" name="sparql">{{ sparql }}</textarea>
          <script>
            // Create global CodeMirror editor instance
            window.editor = CodeMirror.fromTextArea(document.getElementById("sparql"), {
              mode: "sparql",
              lineNumbers: true,
              theme: "default"
            });
            function resizeCodeMirrorToContent(cm) {
              var doc = cm.getDoc();
              var lineCount = doc.lineCount();
              var newHeight = (lineCount + 1) * 24; // 24px is the default line height
              cm.setSize(null, newHeight + "px");
            }
            resizeCodeMirrorToContent(window.editor);
            window.editor.on("change", function (cm) {
              resizeCodeMirrorToContent(cm);
            });
          </script>
        </div>

        <div class="mb-6">
          <button type="submit" id="execute_button" name="execute_button" class="btn btn-outline-primary mb-3">Execute
            SPARQL</button>
        </div>
        <input type="hidden" id="generating_nl" name="generating_nl" value="{{ generating_nl }}">
        <input type="hidden" id="execute_natural_language" name="natural_language" value="{{ natural_language }}">

        <p class="text-danger fw-bold" id="error_message" name="error_message"></p>
      </form>
    </div>

    <div class="container" id="results_div" name="results_div">
      <div class="d-flex justify-content-between align-items-center">
        <h5>{{ results_message }}</h5>
        {% if count and count > 0 %}
        <h6 class="text-muted mb-0">Total Results: {{ count }}</h6>
        {% endif %}
      </div>
      {% if results %}
      <pre><code class="language-json">{{ results | tojson | safe }}</code></pre> {% endif %}
      <!-- Prism.js for JSON syntax highlighting -->
      <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" />
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
      <br/>
    </div>

    <!-- Ontology header and controls (label always visible) -->
    <div class="container" id="ontology_header"
      style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;margin-top:0;">
      <div style="display:flex;align-items:center;gap:12px;">
        <h5 style="margin:0;">Ontology (OWL/Turtle)</h5>
        <div id="ontology_action_controls" style="display:flex;gap:8px;align-items:center;">
          <button type="button" id="edit_owl_button" class="btn btn-sm btn-outline-secondary">Edit</button>
          <!-- Save button removed -->
        </div>
      </div>
      <div>
        <button type="button" id="toggle_ontology_button_ctrl" class="btn btn-sm btn-outline-secondary">Hide Ontology
          &#9650;</button>
      </div>
    </div>
    <br/>
    <div class="container" id="owl_div" name="owl_div">
      <pre><code class="language-turtle" id="owl_code" style="font-size: 12px;">{{ owl }}</code></pre>
      <!-- Prism.js for Turtle and XML syntax highlighting -->
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-turtle.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-xml-doc.min.js"></script>
      <!-- rdflib for robust Turtle/OWL parsing -->
      <script src="https://cdn.jsdelivr.net/npm/rdflib/dist/rdflib.min.js"></script>
    </div>

    <!-- see  https://github.com/visjs/vis-network -->
    <div class="container" id="ontology_div" name="ontology_div">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
        <h5 style="margin:0;">Ontology Visualization</h5>
        <div id="ontology_viz_controls" style="display:flex;gap:8px;align-items:center;">
          <button type="button" id="re_render_owl_button" class="btn btn-sm btn-outline-primary">Re-render</button>
        </div>
      </div>
      <div class="container" id="ontology_viz" style="width:100%;height:768px;border: 0px solid lightgray"></div>
    </div>


  </div>
</div>

{% endblock %}
{% block js %}
<script>

  const nl_form_field = document.getElementById("natural_language");
  const generate_form = document.getElementById("generate_form");
  const generate_button = document.getElementById("generate_button");
  const execute_form = document.getElementById("execute_form");
  const execute_button = document.getElementById("execute_button");

  // Triple-click handler for #natural_language
  let nl_clickCount = 0;
  let nl_clickTimer = null;

  nl_form_field.addEventListener('click', function (event) {
    nl_clickCount++;
    if (nl_clickCount === 1) {
      nl_clickTimer = setTimeout(function () {
        nl_clickCount = 0;
      }, 400);
    } else if (nl_clickCount === 3) {
      clearTimeout(nl_clickTimer);
      nl_clickCount = 0;
      nl_query_index++;
      if (nl_query_index >= nl_queries.length) {
        nl_query_index = 0;
      }
      nl_form_field.value = nl_queries[nl_query_index];
      generate_button.disabled = false;
    }
  });

  var nl_query_index = -1;
  var nl_queries = [
    "What is the most connected node?",
    "What entity has the most outgoing connections?",
    "How many nodes are there?",
    "How many connections are there?",
    "What are the dependencies of the flask library?",
    "What are the dependencies of the pandas library?",
    "What are the dependencies of the openai library?",
    "what 5 libraries have the most dependencies ?"
  ];


  generate_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      generate_button.disabled = true;
      generate_button.textContent = "Processing...";
      execute_button.disabled = true;
      // Mark that we're submitting a form to prevent localStorage restoration
      sessionStorage.setItem('gen_sparql_form_submitted', 'true');
      generate_form.submit();
    }
  );


  execute_button.addEventListener('click',
    function (event) {
      event.preventDefault();
      // Sync the current value of the textarea to the hidden input before submit
      document.getElementById('execute_natural_language').value = nl_form_field.value;
      execute_button.disabled = true;
      execute_button.textContent = "Processing...";
      generate_button.disabled = true;
      execute_form.submit();
    }
  );



</script>
<!--
This <script> section was generated from an OWL file using this command:
python main_common.py owl_visualizer ontologies/libraries.owl
-->
<script type="text/javascript">
  // Dynamically build the vis.js graph from the OWL/Turtle text rendered in
  // the page under #owl_div <code> block. This keeps the view Jinja2-friendly
  // and generates nodes/edges on page load without hardcoding the graph.

  function simpleTurtleToGraph(turtleText) {
    // Very small heuristic parser: extract triples of the form
    // subject predicate object .  Handles multiple objects separated by commas.
    const nodesSet = new Map(); // id -> {id,label}
    const edges = [];

    const lines = turtleText.split(/\r?\n/);
    for (let raw of lines) {
      let line = raw.replace(/#.*$/, '').trim();
      if (!line) continue;
      // Only handle simple triple lines ending with a dot
      if (!line.endsWith('.')) continue;
      // remove trailing dot
      line = line.slice(0, -1).trim();

      // split subject, predicate, objects (objects may include commas or ';')
      const m = line.match(/^([^\s]+)\s+([^\s]+)\s+(.+)$/);
      if (!m) continue;
      let subj = m[1];
      let pred = m[2];
      let objs = m[3];

      // split objects on comma (ignore language tags / nested constructs)
      objs = objs.split(',').map(s => s.trim());

      // normalize token function: strip prefixes and angle brackets
      const norm = (token) => {
        if (!token) return token;
        // literal string
        if (token.startsWith('"') || token.startsWith("'")) return null;
        // remove trailing punctuation
        token = token.replace(/^<|>$/g, '');
        // if contains ':' return local part after ':' else return token
        if (token.indexOf(':') >= 0) {
          return token.split(':').pop();
        }
        return token;
      };

      const sId = norm(subj);
      if (sId) nodesSet.set(sId, { id: sId, label: sId });

      for (let objRaw of objs) {
        // remove predicate modifiers like ; ... (we only handle commas already split)
        // also chop off trailing whitespace or comments
        let obj = objRaw.replace(/;.*$/, '').trim();
        const oId = norm(obj);
        if (!oId) continue; // skip literals
        nodesSet.set(oId, { id: oId, label: oId });

        // derive predicate label
        const pLabel = norm(pred) || pred;
        if (!pLabel) continue;

        edges.push({ from: sId, to: oId, title: pLabel, label: pLabel });
      }
    }

    // Convert nodesSet to array
    const nodes = Array.from(nodesSet.values());
    return { nodes, edges };
  }

  async function renderOntologyGraph() {
    try {
      // get turtle text from the owl_div code block
      const codeEl = document.querySelector('#owl_div code');
      const turtleText = codeEl ? codeEl.innerText || codeEl.textContent : '';
      let graph = { nodes: [], edges: [] };
      if (turtleText && turtleText.trim().length > 0) {
        // Prefer rdflib.js parsing for correctness; fallback to heuristic parser
        try {
          // rdflibToGraph returns a Promise
          graph = await rdflibToGraph(turtleText);
          // If rdflib produced no nodes, fall back
          if (!graph || !graph.nodes || graph.nodes.length === 0) {
            graph = simpleTurtleToGraph(turtleText);
          }
        } catch (e) {
          console.warn('rdflib parsing failed, falling back to heuristic parser:', e);
          graph = simpleTurtleToGraph(turtleText);
        }
      }

      // fallback if parse produced no nodes
      if (!graph.nodes.length) {
        graph = {
          nodes: [{ id: 'Dev', label: 'Dev' }, { id: 'Doc', label: 'Doc' }, { id: 'Lib', label: 'Lib' }],
          edges: [{ from: 'Dev', to: 'Lib', title: 'developer_of' }, { from: 'Lib', to: 'Dev', title: 'developed_by' }, { from: 'Lib', to: 'Lib', title: 'used_by_lib, uses_lib' }]
        };
      }

      // create vis DataSets
      // Generate random dark color for each node
      function randomDarkColor() {
        // HSL: hue random, sat 40-60%, lightness 15-30%
        const h = Math.floor(Math.random() * 360);
        const s = 40 + Math.floor(Math.random() * 20);
        const l = 15 + Math.floor(Math.random() * 15);
        return `hsl(${h},${s}%,${l}%)`;
      }
      const nodes = new vis.DataSet(graph.nodes.map((n) => {
        const color = randomDarkColor();
        return {
          id: n.id,
          label: n.label,
          shape: "box",
          color: {
            background: color,
            border: color,
            highlight: { background: color, border: color },
            hover: { background: color, border: color }
          },
          font: {
            color: "#fff",
            size: 18,
            face: 'Lucida Console',
            bold: true
          },
          borderWidth: 0,
          margin: 10
        };
      }));
      const edges = new vis.DataSet(graph.edges.map(e => ({
        from: e.from,
        to: e.to,
        label: e.label,
        title: e.title,
        font: {
          color: "#90caf9", // light blue
          strokeWidth: 0,   // no border/stroke
          size: 12,
          face: 'Lucida Console',
          align: 'middle',
          vadjust: -8 // move label slightly above the line
        },
        color: {
          color: "#b0bec5",
          highlight: "#90caf9",
          hover: "#90caf9"
        },
        arrows: { to: { enabled: true, scaleFactor: 0.2, type: 'arrow' } },
        smooth: {
          enabled: true,
          type: "dynamic"
        },
        shadow: false
      })));
      const html_container = document.getElementById('ontology_viz');
      const graph_data = { nodes: nodes, edges: edges };
      const graph_options = {
        nodes: {
          shape: "box",
          borderWidth: 0,
          margin: 10,
          font: {
            size: 18,
            face: 'Lucida Console',
            bold: true,
            color: "#fff"
          }
        },
        edges: {
          arrows: { to: { enabled: true, scaleFactor: 0.2, type: 'arrow' } },
          color: "#b0bec5",
          font: {
            color: "#90caf9",
            strokeWidth: 0, // no border/stroke
            size: 12,
            face: 'Lucida Console',
            align: 'middle',
            vadjust: -8 // move label slightly above the line
          },
          scaling: { label: true },
          shadow: false,
          smooth: {
            enabled: true,
            type: "dynamic"
          }
        },
        physics: { enabled: true, repulsion: { centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 200, damping: 0.09 } }
      };

      // clear previous network if present
      if (window.__ontology_network) {
        try { window.__ontology_network.destroy(); } catch (e) { }
      }
      window.__ontology_network = new vis.Network(html_container, graph_data, graph_options);
    } catch (e) {
      console.error('Error rendering ontology graph:', e);
    }
  }

  // Initial render
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
      renderOntologyGraph();
    }, 100);
  });

  // Re-render on button click
  document.getElementById('re_render_owl_button').addEventListener('click', function () {
    renderOntologyGraph();
  });



  // Unified ontology edit/save/toggle logic
  (function() {
    const editBtn      = document.getElementById('edit_owl_button');
    const toggleBtn    = document.getElementById('toggle_ontology_button_ctrl');
    const rerenderBtn  = document.getElementById('re_render_owl_button');
    const owlDiv       = document.getElementById('owl_div');
    const ontDiv       = document.getElementById('ontology_div');
    const actionCtrls  = document.getElementById('ontology_action_controls');
    let owlEditor = null;

    function detectOntologyFormat(content) {
      if (!content) return 'turtle';
      const t = content.trim();
      if (t.startsWith('<?xml') || t.startsWith('<rdf:RDF') || t.includes('<owl:') || t.includes('xmlns:owl=')
          || t.includes('xmlns:rdf=')) return 'xml';
      if (t.includes('@prefix') || t.includes('@base') || /(^|\s)PREFIX\s/i.test(t) || /\s+a\s+/.test(t))
        return 'turtle';
      return 'turtle';
    }
    function resizeEditor(cm) {
      const lc = cm.getDoc().lineCount();
      cm.setSize(null, Math.max((lc + 1) * 24, 240) + 'px');
    }
    function enterEditMode() {
      if (owlEditor) return;
      const codeBlock = document.getElementById('owl_code');
      if (!codeBlock) return;
      const content = codeBlock.textContent;
      const format = detectOntologyFormat(content);
      const ta = document.createElement('textarea');
      ta.id = 'owl_edit_textarea';
      ta.style.width = '100%';
      ta.style.minHeight = '240px';
      ta.value = content;
      codeBlock.parentNode.replaceChild(ta, codeBlock);
      owlEditor = CodeMirror.fromTextArea(ta, {
        mode: format === 'xml' ? 'xml' : 'turtle',
        lineNumbers: true,
        theme: 'default'
      });
      resizeEditor(owlEditor);
      owlEditor.on('change', resizeEditor);
      editBtn.textContent = 'Save';
    }
    function exitEditMode(replacementContent) {
      if (!owlEditor) return;
      const content = replacementContent !== undefined ? replacementContent : owlEditor.getValue();
      const format = detectOntologyFormat(content);
      const newCode = document.createElement('code');
      newCode.id = 'owl_code';
      newCode.className = format === 'xml' ? 'language-xml' : 'language-turtle';
      newCode.style.fontSize = '12px';
      newCode.textContent = content;
      const wrapper = owlEditor.getWrapperElement();
      wrapper.parentNode.replaceChild(newCode, wrapper);
      try { if (window.Prism) Prism.highlightElement(newCode); } catch(e){}
      owlEditor = null;
      editBtn.textContent = 'Edit';
    }
    function saveOntology() {
      if (!owlEditor) return;
      const content = owlEditor.getValue();
      editBtn.disabled = true;
      const priorLabel = editBtn.textContent;
      editBtn.textContent = 'Saving...';
      fetch('/api/save_ontology', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ content })
      })
      .then(r => r.json())
      .then(j => {
        if (j.success) {
          alert('Ontology saved.');
          exitEditMode(content);
        } else {
          console.error('Save ontology failed:', j);
          alert('Save failed: ' + (j.error || 'Unknown error'));
          // Keep in edit mode so user can retry (do NOT exit)
          editBtn.textContent = 'Retry Save';
        }
      })
      .catch(e => {
        console.error('Save ontology network/error:', e);
        alert('Save failed: ' + e);
        editBtn.textContent = 'Retry Save';
      })
      .finally(() => {
        editBtn.disabled = false;
        if (!owlEditor && editBtn.textContent !== 'Edit') {
          // If we exited edit mode successfully, ensure label is Edit
          editBtn.textContent = 'Edit';
        }
        if (owlEditor && editBtn.textContent === 'Saving...') {
          // If still in edit mode but no label update happened, restore to Retry Save
          editBtn.textContent = 'Retry Save';
        }
      });
    }

    editBtn.addEventListener('click', function(e) {
      e.preventDefault();
      if (!owlEditor) {
        enterEditMode();
      } else {
        saveOntology();
      }
    });

    toggleBtn.addEventListener('click', function(e) {
      e.preventDefault();
      const visible = owlDiv.style.display !== 'none';
      const newVisible = !visible;
      owlDiv.style.display = newVisible ? '' : 'none';
      ontDiv.style.display = newVisible ? '' : 'none';
      actionCtrls.style.display = newVisible ? 'flex' : 'none';
      toggleBtn.innerHTML = newVisible ? 'Hide Ontology &#9650;' : 'Show Ontology &#9660;';
      try { sessionStorage.setItem('ontologyVisible', newVisible.toString()); } catch(e){}
      if (newVisible) renderOntologyGraph();
    });

    // Restore persisted visibility
    (function restoreVisibility() {
      let vis = true;
      try {
        const stored = sessionStorage.getItem('ontologyVisible');
        if (stored === 'false') vis = false;
      } catch(e){}
      if (!vis) {
        owlDiv.style.display = 'none';
        ontDiv.style.display = 'none';
        actionCtrls.style.display = 'none';
        toggleBtn.innerHTML = 'Show Ontology &#9660;';
      } else {
        toggleBtn.innerHTML = 'Hide Ontology &#9650;';
      }
    })();

    rerenderBtn.addEventListener('click', function(e) {
      e.preventDefault();
      if (owlEditor) {
        // temporarily get content for graph parse
        const content = owlEditor.getValue();
        exitEditMode(content);
        renderOntologyGraph();
        enterEditMode();
      } else {
        renderOntologyGraph();
      }
    });
  })();
</script>

{% endblock %}